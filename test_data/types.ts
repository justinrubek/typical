// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

export function unreachable(x: never): never {
  return x;
}

function zigzagEncode(value: bigint): bigint {
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}

function zigzagDecode(value: bigint): bigint {
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}

function varintSizeFromValue(value: bigint): number {
  if (value < 128n) {
    return 1;
  }

  if (value < 16_512n) {
    return 2;
  }

  if (value < 2_113_664n) {
    return 3;
  }

  if (value < 270_549_120n) {
    return 4;
  }

  if (value < 34_630_287_488n) {
    return 5;
  }

  if (value < 4_432_676_798_592n) {
    return 6;
  }

  if (value < 567_382_630_219_904n) {
    return 7;
  }

  if (value < 72_624_976_668_147_840n) {
    return 8;
  }

  return 9;
}

function varintSizeFromFirstByte(firstByte: number): number {
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {
    trailingZeros += 1;
    firstByte >>= 1;
  }

  return trailingZeros + 1;
}

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {
  if (value < 128n) {
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  }

  if (value < 16_512n) {
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  }

  if (value < 2_113_664n) {
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  }

  if (value < 270_549_120n) {
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  }

  if (value < 34_630_287_488n) {
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  }

  if (value < 4_432_676_798_592n) {
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  }

  if (value < 567_382_630_219_904n) {
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  }

  if (value < 72_624_976_668_147_840n) {
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  }

  value -= 72_624_976_668_147_840n;
  dataView.setUint8(offset, 0b0000_0000);
  dataView.setBigUint64(offset + 1, value, true);
  return offset + 9;
}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;

  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(0, 0n, true);
  for (let i = 0; i < sizeMinusOne; i += 1) {
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }
  const remainingBytesValue = dataView64.getBigUint64(0, true);

  switch (sizeMinusOne) {
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }
}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return varintSizeFromValue(index << 2n);
    case 8:
      return varintSizeFromValue((index << 2n) | 1n);
    default:
      if (integerEncoded) {
        return varintSizeFromValue((index << 2n) | 2n);
      }

      return (
        varintSizeFromValue((index << 2n) | 3n) +
        varintSizeFromValue(BigInt(payloadSize))
      );
  }
}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return serializeVarint(dataView, offset, index << 2n);
    case 8:
      return serializeVarint(dataView, offset, (index << 2n) | 1n);
    default:
      if (integerEncoded) {
        return serializeVarint(dataView, offset, (index << 2n) | 2n);
      }

      offset = serializeVarint(dataView, offset, (index << 2n) | 3n);

      return serializeVarint(dataView, offset, BigInt(payloadSize));
  }
}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {
  const [newOffset, tag] = deserializeVarint(dataView, offset);

  const index = tag >> 2n;

  switch (tag & 3n) {
    case 0n:
      return [newOffset, index, 0];
    case 1n:
      return [newOffset, index, 8];
    case 2n:
      return [newOffset, index, varintSizeFromFirstByte(dataView.getUint8(newOffset))];
    default: {
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, newOffset);
      return [newNewOffset, index, Number(sizeValue)];
    }
  }
}

const missingFieldsErrorMessage = 'Struct missing one or more required field(s).';
const dataView64 = new DataView(new ArrayBuffer(8));
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

export namespace CircularDependency {
  export namespace Dependency {
    export namespace Types {
      export type StructFromBelowAtlas = {
        $size: number;
        x: CircularDependency.Types.StructFromAboveAtlas;
      };

      export type StructFromBelowOut = {
        x: CircularDependency.Types.StructFromAboveOut;
      };

      export type StructFromBelowIn = {
        x: CircularDependency.Types.StructFromAboveIn;
      };

      export namespace StructFromBelow {
        export function size(message: StructFromBelowOut): number {
          return atlas(message).$size;
        }

        export function serialize(message: StructFromBelowOut): ArrayBuffer {
          const messageAtlas = atlas(message);
          const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
          const dataView = new DataView(arrayBuffer);
          serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
          return arrayBuffer;
        }

        export function deserialize(dataView: DataView): StructFromBelowIn | Error {
          try {
            return deserializeUnsafe(dataView);
          } catch (e) {
            return e as Error;
          }
        }

        export function atlas(message: StructFromBelowOut): StructFromBelowAtlas {
          let size = 0;

          let $x;

          {
            let payloadAtlas;
            const payload = message.x;
            payloadAtlas = CircularDependency.Types.StructFromAbove.atlas(payload);
            $x = payloadAtlas;
            const payloadSize = (payloadAtlas as { $size: number }).$size;
            size += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }

          return {
            $size: size,
            x: $x,
          };
        }

        export function serializeWithAtlasUnsafe(
          dataView: DataView,
          offset: number,
          message: StructFromBelowOut,
          atlas: StructFromBelowAtlas,
        ): number {
          {
            const payload = message.x;
            const payloadAtlas = atlas.x;
            const payloadSize = (payloadAtlas as { $size: number }).$size;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = CircularDependency.Types.StructFromAbove.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          }

          return offset;
        }

        export function deserializeUnsafe(dataView: DataView): StructFromBelowIn {
          const dataViewAlias = dataView;

          let offset = 0;

          let $x;

          while (true) {
            let index, payloadSize;

            try {
              [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
            } catch (e) {
              if (e instanceof RangeError) {
                break;
              } else {
                throw e;
              }
            }

            switch (index) {
              case 0n: {
                const dataView = new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  payloadSize,
                );
                const oldOffset = offset;
                offset = 0;
                let payload = CircularDependency.Types.StructFromAbove.deserializeUnsafe(dataView);
                offset = dataView.byteLength;
                offset += oldOffset;
                $x = payload;
                break;
              }
              default:
                offset += payloadSize;
                break;
            }
          }

          if ($x === undefined) {
            throw new Error(missingFieldsErrorMessage);
          }

          return {
            x: $x,
          };
        }
      }
    }
  }

  export namespace Types {
    export type StructFromAboveAtlas = {
      $size: number;
      field: Uint8Array;
      size: Uint8Array;
      elements: Uint8Array;
      fallback: Uint8Array;
    };

    export type StructFromAboveOut = {
      field: string;
      size: string;
      elements: string;
      fallback: string;
    };

    export type StructFromAboveIn = {
      field: string;
      size: string;
      elements: string;
      fallback: string;
    };

    export namespace StructFromAbove {
      export function size(message: StructFromAboveOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: StructFromAboveOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): StructFromAboveIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: StructFromAboveOut): StructFromAboveAtlas {
        let size = 0;

        let $field, $size, $elements, $fallback;

        {
          let payloadAtlas;
          const payload = message.field;
          payloadAtlas = textEncoder.encode(payload);
          $field = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.size;
          payloadAtlas = textEncoder.encode(payload);
          $size = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.elements;
          payloadAtlas = textEncoder.encode(payload);
          $elements = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.fallback;
          payloadAtlas = textEncoder.encode(payload);
          $fallback = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(3n, payloadSize, false) + payloadSize;
        }

        return {
          $size: size,
          field: $field,
          size: $size,
          elements: $elements,
          fallback: $fallback,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: StructFromAboveOut,
        atlas: StructFromAboveAtlas,
      ): number {
        {
          const payload = message.field;
          const payloadAtlas = atlas.field;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.size;
          const payloadAtlas = atlas.size;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.elements;
          const payloadAtlas = atlas.elements;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.fallback;
          const payloadAtlas = atlas.fallback;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): StructFromAboveIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $field, $size, $elements, $fallback;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $field = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $size = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $elements = payload;
              break;
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fallback = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($field === undefined
          || $size === undefined
          || $elements === undefined
          || $fallback === undefined) {
          throw new Error(missingFieldsErrorMessage);
        }

        return {
          field: $field,
          size: $size,
          elements: $elements,
          fallback: $fallback,
        };
      }
    }
  }
}

export namespace Comprehensive {
  export namespace Types {
    export type LocalStructAtlas = {
      $size: number;
    };

    export type LocalStructOut = {
    };

    export type LocalStructIn = {
    };

    export namespace LocalStruct {
      export function size(message: LocalStructOut): number {
        return 0;
      }

      export function serialize(message: LocalStructOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): LocalStructIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: LocalStructOut): LocalStructAtlas {
        let size = 0;

        return {
          $size: size,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: LocalStructOut,
        atlas: LocalStructAtlas,
      ): number {
        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): LocalStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            default:
              offset += payloadSize;
              break;
          }
        }

        return {
        };
      }
    }

    export type FooAtlas = {
      $size: number;
      aRequired: number;
      bRequired: number;
      cRequired: number;
      dRequired: number;
      eRequired: number;
      fRequired: number;
      gRequired: Uint8Array;
      hRequired: Comprehensive.Types.LocalStructAtlas;
      iRequired: Degenerate.Types.EmptyStructAtlas;
      jRequired: number;
      kRequired: number;
      lRequired: number;
      mRequired: number;
      nRequired: number;
      oRequired: { $size: number; $elements: number[] };
      pRequired: { $size: number; $elements: Uint8Array[] };
      qRequired: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] };
      rRequired: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] };
      sRequired: { $size: number; $elements: number[] };
      tRequired: { $size: number; $elements: number[] };
      uRequired: { $size: number; $elements: number[] };
      vRequired: { $size: number; $elements: number[] };
      wRequired: { $size: number; $elements: number[] };
      xRequired: { $size: number; $elements: { $size: number; $elements: number[] }[] };
      yRequired: { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] };
      zRequired: { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] };
      aaRequired: { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] };
      aAsymmetric: number;
      bAsymmetric: number;
      cAsymmetric: number;
      dAsymmetric: number;
      eAsymmetric: number;
      fAsymmetric: number;
      gAsymmetric: Uint8Array;
      hAsymmetric: Comprehensive.Types.LocalStructAtlas;
      iAsymmetric: Degenerate.Types.EmptyStructAtlas;
      jAsymmetric: number;
      kAsymmetric: number;
      lAsymmetric: number;
      mAsymmetric: number;
      nAsymmetric: number;
      oAsymmetric: { $size: number; $elements: number[] };
      pAsymmetric: { $size: number; $elements: Uint8Array[] };
      qAsymmetric: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] };
      rAsymmetric: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] };
      sAsymmetric: { $size: number; $elements: number[] };
      tAsymmetric: { $size: number; $elements: number[] };
      uAsymmetric: { $size: number; $elements: number[] };
      vAsymmetric: { $size: number; $elements: number[] };
      wAsymmetric: { $size: number; $elements: number[] };
      xAsymmetric: { $size: number; $elements: { $size: number; $elements: number[] }[] };
      yAsymmetric: { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] };
      zAsymmetric: { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] };
      aaAsymmetric: { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] };
      aOptional: number | undefined;
      bOptional: number | undefined;
      cOptional: number | undefined;
      dOptional: number | undefined;
      eOptional: number | undefined;
      fOptional: number | undefined;
      gOptional: Uint8Array | undefined;
      hOptional: Comprehensive.Types.LocalStructAtlas | undefined;
      iOptional: Degenerate.Types.EmptyStructAtlas | undefined;
      jOptional: number | undefined;
      kOptional: number | undefined;
      lOptional: number | undefined;
      mOptional: number | undefined;
      nOptional: number | undefined;
      oOptional: { $size: number; $elements: number[] } | undefined;
      pOptional: { $size: number; $elements: Uint8Array[] } | undefined;
      qOptional: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] } | undefined;
      rOptional: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] } | undefined;
      sOptional: { $size: number; $elements: number[] } | undefined;
      tOptional: { $size: number; $elements: number[] } | undefined;
      uOptional: { $size: number; $elements: number[] } | undefined;
      vOptional: { $size: number; $elements: number[] } | undefined;
      wOptional: { $size: number; $elements: number[] } | undefined;
      xOptional: { $size: number; $elements: { $size: number; $elements: number[] }[] } | undefined;
      yOptional: { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] } | undefined;
      zOptional: { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] } | undefined;
      aaOptional: { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] } | undefined;
    };

    export type FooOut = {
      aRequired: null;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: Comprehensive.Types.LocalStructOut;
      iRequired: Degenerate.Types.EmptyStructOut;
      jRequired: null[];
      kRequired: number[];
      lRequired: bigint[];
      mRequired: bigint[];
      nRequired: boolean[];
      oRequired: ArrayBuffer[];
      pRequired: string[];
      qRequired: Comprehensive.Types.LocalStructOut[];
      rRequired: Degenerate.Types.EmptyStructOut[];
      sRequired: null[][];
      tRequired: number[][];
      uRequired: bigint[][];
      vRequired: bigint[][];
      wRequired: boolean[][];
      xRequired: ArrayBuffer[][];
      yRequired: string[][];
      zRequired: Comprehensive.Types.LocalStructOut[][];
      aaRequired: Degenerate.Types.EmptyStructOut[][];
      aAsymmetric: null;
      bAsymmetric: number;
      cAsymmetric: bigint;
      dAsymmetric: bigint;
      eAsymmetric: boolean;
      fAsymmetric: ArrayBuffer;
      gAsymmetric: string;
      hAsymmetric: Comprehensive.Types.LocalStructOut;
      iAsymmetric: Degenerate.Types.EmptyStructOut;
      jAsymmetric: null[];
      kAsymmetric: number[];
      lAsymmetric: bigint[];
      mAsymmetric: bigint[];
      nAsymmetric: boolean[];
      oAsymmetric: ArrayBuffer[];
      pAsymmetric: string[];
      qAsymmetric: Comprehensive.Types.LocalStructOut[];
      rAsymmetric: Degenerate.Types.EmptyStructOut[];
      sAsymmetric: null[][];
      tAsymmetric: number[][];
      uAsymmetric: bigint[][];
      vAsymmetric: bigint[][];
      wAsymmetric: boolean[][];
      xAsymmetric: ArrayBuffer[][];
      yAsymmetric: string[][];
      zAsymmetric: Comprehensive.Types.LocalStructOut[][];
      aaAsymmetric: Degenerate.Types.EmptyStructOut[][];
      aOptional: null | undefined;
      bOptional: number | undefined;
      cOptional: bigint | undefined;
      dOptional: bigint | undefined;
      eOptional: boolean | undefined;
      fOptional: ArrayBuffer | undefined;
      gOptional: string | undefined;
      hOptional: Comprehensive.Types.LocalStructOut | undefined;
      iOptional: Degenerate.Types.EmptyStructOut | undefined;
      jOptional: null[] | undefined;
      kOptional: number[] | undefined;
      lOptional: bigint[] | undefined;
      mOptional: bigint[] | undefined;
      nOptional: boolean[] | undefined;
      oOptional: ArrayBuffer[] | undefined;
      pOptional: string[] | undefined;
      qOptional: Comprehensive.Types.LocalStructOut[] | undefined;
      rOptional: Degenerate.Types.EmptyStructOut[] | undefined;
      sOptional: null[][] | undefined;
      tOptional: number[][] | undefined;
      uOptional: bigint[][] | undefined;
      vOptional: bigint[][] | undefined;
      wOptional: boolean[][] | undefined;
      xOptional: ArrayBuffer[][] | undefined;
      yOptional: string[][] | undefined;
      zOptional: Comprehensive.Types.LocalStructOut[][] | undefined;
      aaOptional: Degenerate.Types.EmptyStructOut[][] | undefined;
    };

    export type FooIn = {
      aRequired: null;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: Comprehensive.Types.LocalStructIn;
      iRequired: Degenerate.Types.EmptyStructIn;
      jRequired: null[];
      kRequired: number[];
      lRequired: bigint[];
      mRequired: bigint[];
      nRequired: boolean[];
      oRequired: ArrayBuffer[];
      pRequired: string[];
      qRequired: Comprehensive.Types.LocalStructIn[];
      rRequired: Degenerate.Types.EmptyStructIn[];
      sRequired: null[][];
      tRequired: number[][];
      uRequired: bigint[][];
      vRequired: bigint[][];
      wRequired: boolean[][];
      xRequired: ArrayBuffer[][];
      yRequired: string[][];
      zRequired: Comprehensive.Types.LocalStructIn[][];
      aaRequired: Degenerate.Types.EmptyStructIn[][];
      aAsymmetric: null | undefined;
      bAsymmetric: number | undefined;
      cAsymmetric: bigint | undefined;
      dAsymmetric: bigint | undefined;
      eAsymmetric: boolean | undefined;
      fAsymmetric: ArrayBuffer | undefined;
      gAsymmetric: string | undefined;
      hAsymmetric: Comprehensive.Types.LocalStructIn | undefined;
      iAsymmetric: Degenerate.Types.EmptyStructIn | undefined;
      jAsymmetric: null[] | undefined;
      kAsymmetric: number[] | undefined;
      lAsymmetric: bigint[] | undefined;
      mAsymmetric: bigint[] | undefined;
      nAsymmetric: boolean[] | undefined;
      oAsymmetric: ArrayBuffer[] | undefined;
      pAsymmetric: string[] | undefined;
      qAsymmetric: Comprehensive.Types.LocalStructIn[] | undefined;
      rAsymmetric: Degenerate.Types.EmptyStructIn[] | undefined;
      sAsymmetric: null[][] | undefined;
      tAsymmetric: number[][] | undefined;
      uAsymmetric: bigint[][] | undefined;
      vAsymmetric: bigint[][] | undefined;
      wAsymmetric: boolean[][] | undefined;
      xAsymmetric: ArrayBuffer[][] | undefined;
      yAsymmetric: string[][] | undefined;
      zAsymmetric: Comprehensive.Types.LocalStructIn[][] | undefined;
      aaAsymmetric: Degenerate.Types.EmptyStructIn[][] | undefined;
      aOptional: null | undefined;
      bOptional: number | undefined;
      cOptional: bigint | undefined;
      dOptional: bigint | undefined;
      eOptional: boolean | undefined;
      fOptional: ArrayBuffer | undefined;
      gOptional: string | undefined;
      hOptional: Comprehensive.Types.LocalStructIn | undefined;
      iOptional: Degenerate.Types.EmptyStructIn | undefined;
      jOptional: null[] | undefined;
      kOptional: number[] | undefined;
      lOptional: bigint[] | undefined;
      mOptional: bigint[] | undefined;
      nOptional: boolean[] | undefined;
      oOptional: ArrayBuffer[] | undefined;
      pOptional: string[] | undefined;
      qOptional: Comprehensive.Types.LocalStructIn[] | undefined;
      rOptional: Degenerate.Types.EmptyStructIn[] | undefined;
      sOptional: null[][] | undefined;
      tOptional: number[][] | undefined;
      uOptional: bigint[][] | undefined;
      vOptional: bigint[][] | undefined;
      wOptional: boolean[][] | undefined;
      xOptional: ArrayBuffer[][] | undefined;
      yOptional: string[][] | undefined;
      zOptional: Comprehensive.Types.LocalStructIn[][] | undefined;
      aaOptional: Degenerate.Types.EmptyStructIn[][] | undefined;
    };

    export namespace Foo {
      export function size(message: FooOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: FooOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): FooIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: FooOut): FooAtlas {
        let size = 0;

        let $aRequired, $bRequired, $cRequired, $dRequired, $eRequired, $fRequired, $gRequired, $hRequired, $iRequired, $jRequired, $kRequired, $lRequired, $mRequired, $nRequired, $oRequired, $pRequired, $qRequired, $rRequired, $sRequired, $tRequired, $uRequired, $vRequired, $wRequired, $xRequired, $yRequired, $zRequired, $aaRequired, $aAsymmetric, $bAsymmetric, $cAsymmetric, $dAsymmetric, $eAsymmetric, $fAsymmetric, $gAsymmetric, $hAsymmetric, $iAsymmetric, $jAsymmetric, $kAsymmetric, $lAsymmetric, $mAsymmetric, $nAsymmetric, $oAsymmetric, $pAsymmetric, $qAsymmetric, $rAsymmetric, $sAsymmetric, $tAsymmetric, $uAsymmetric, $vAsymmetric, $wAsymmetric, $xAsymmetric, $yAsymmetric, $zAsymmetric, $aaAsymmetric, $aOptional, $bOptional, $cOptional, $dOptional, $eOptional, $fOptional, $gOptional, $hOptional, $iOptional, $jOptional, $kOptional, $lOptional, $mOptional, $nOptional, $oOptional, $pOptional, $qOptional, $rOptional, $sOptional, $tOptional, $uOptional, $vOptional, $wOptional, $xOptional, $yOptional, $zOptional, $aaOptional;

        {
          let payloadAtlas;
          const payload = message.aRequired;
          payloadAtlas = 0;
          $aRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.bRequired;
          if (Object.is(payload, 0)) {
            payloadAtlas = 0;
          } else {
            payloadAtlas = 8;
          }
          $bRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.cRequired;
          if (payload === 0n) {
            payloadAtlas = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadAtlas = varintSizeFromValue(payload);
          } else {
            payloadAtlas = 8;
          }
          $cRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(2n, payloadSize, true) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadAtlas = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadAtlas = varintSizeFromValue(zigzag);
            } else {
              payloadAtlas = 8;
            }
          }
          $dRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(3n, payloadSize, true) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.eRequired;
          if (payload) {
            payloadAtlas = 1;
          } else {
            payloadAtlas = 0;
          }
          $eRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(4n, payloadSize, true) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.fRequired;
          payloadAtlas = payload.byteLength;
          $fRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.gRequired;
          payloadAtlas = textEncoder.encode(payload);
          $gRequired = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.hRequired;
          payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
          $hRequired = payloadAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          size += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.iRequired;
          payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
          $iRequired = payloadAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          size += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.jRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadAtlas = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadAtlas = varintSizeFromValue(payload);
              } else {
                payloadAtlas = 8;
              }
            }
          }
          $jRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.kRequired;
          payloadAtlas = 8 * payload.length;
          $kRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(payload);
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          $lRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          $mRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = 1;
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          $nRequired = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.oRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = payload.byteLength;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $oRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.pRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = textEncoder.encode(payload);
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.byteLength;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $pRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(15n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.qRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $qRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(16n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.rRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $rRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.sRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadAtlas = varintSizeFromValue(payload);
                }
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $sRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(18n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.tRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = 8 * payload.length;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $tRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(19n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.uRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(payload);
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $uRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(20n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.vRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $vRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(21n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.wRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = 1;
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $wRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(22n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.xRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = payload.byteLength;
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $xRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(23n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.yRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = textEncoder.encode(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas.byteLength;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $yRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(24n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.zRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $zRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(25n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.aaRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $aaRequired = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(26n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.aAsymmetric;
          payloadAtlas = 0;
          $aAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(28n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.bAsymmetric;
          if (Object.is(payload, 0)) {
            payloadAtlas = 0;
          } else {
            payloadAtlas = 8;
          }
          $bAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(29n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.cAsymmetric;
          if (payload === 0n) {
            payloadAtlas = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadAtlas = varintSizeFromValue(payload);
          } else {
            payloadAtlas = 8;
          }
          $cAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(30n, payloadSize, true) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadAtlas = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadAtlas = varintSizeFromValue(zigzag);
            } else {
              payloadAtlas = 8;
            }
          }
          $dAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(31n, payloadSize, true) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.eAsymmetric;
          if (payload) {
            payloadAtlas = 1;
          } else {
            payloadAtlas = 0;
          }
          $eAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(32n, payloadSize, true) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.fAsymmetric;
          payloadAtlas = payload.byteLength;
          $fAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(33n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.gAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          $gAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(34n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.hAsymmetric;
          payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
          $hAsymmetric = payloadAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          size += fieldHeaderSize(35n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.iAsymmetric;
          payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
          $iAsymmetric = payloadAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          size += fieldHeaderSize(36n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.jAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadAtlas = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadAtlas = varintSizeFromValue(payload);
              } else {
                payloadAtlas = 8;
              }
            }
          }
          $jAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(37n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.kAsymmetric;
          payloadAtlas = 8 * payload.length;
          $kAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(38n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(payload);
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          $lAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(39n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          $mAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(40n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = 1;
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          $nAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(41n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.oAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = payload.byteLength;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $oAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(42n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.pAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = textEncoder.encode(payload);
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.byteLength;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $pAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(43n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.qAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $qAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(44n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.rAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $rAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(45n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.sAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadAtlas = varintSizeFromValue(payload);
                }
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $sAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(46n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.tAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = 8 * payload.length;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $tAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(47n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.uAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(payload);
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $uAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(48n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.vAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $vAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(49n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.wAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = 1;
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $wAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(50n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.xAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = payload.byteLength;
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $xAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(51n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.yAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = textEncoder.encode(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas.byteLength;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $yAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(52n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.zAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $zAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(53n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.aaAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          $aaAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.$size;
          size += fieldHeaderSize(54n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.aOptional;
          if (payload !== undefined) {
            payloadAtlas = 0;
            $aOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(56n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.bOptional;
          if (payload !== undefined) {
            if (Object.is(payload, 0)) {
              payloadAtlas = 0;
            } else {
              payloadAtlas = 8;
            }
            $bOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(57n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.cOptional;
          if (payload !== undefined) {
            if (payload === 0n) {
              payloadAtlas = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadAtlas = varintSizeFromValue(payload);
            } else {
              payloadAtlas = 8;
            }
            $cOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(58n, payloadSize, true) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.dOptional;
          if (payload !== undefined) {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadAtlas = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadAtlas = varintSizeFromValue(zigzag);
              } else {
                payloadAtlas = 8;
              }
            }
            $dOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(59n, payloadSize, true) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.eOptional;
          if (payload !== undefined) {
            if (payload) {
              payloadAtlas = 1;
            } else {
              payloadAtlas = 0;
            }
            $eOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(60n, payloadSize, true) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.fOptional;
          if (payload !== undefined) {
            payloadAtlas = payload.byteLength;
            $fOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(61n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.gOptional;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $gOptional = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(62n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.hOptional;
          if (payload !== undefined) {
            payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
            $hOptional = payloadAtlas;
            const payloadSize = (payloadAtlas as { $size: number }).$size;
            size += fieldHeaderSize(63n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.iOptional;
          if (payload !== undefined) {
            payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
            $iOptional = payloadAtlas;
            const payloadSize = (payloadAtlas as { $size: number }).$size;
            size += fieldHeaderSize(64n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.jOptional;
          if (payload !== undefined) {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadAtlas = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadAtlas = varintSizeFromValue(payload);
                } else {
                  payloadAtlas = 8;
                }
              }
            }
            $jOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(65n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.kOptional;
          if (payload !== undefined) {
            payloadAtlas = 8 * payload.length;
            $kOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(66n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.lOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas = 0;
                payloadAtlas = varintSizeFromValue(payload);
                arraySize += payloadAtlas;
              }
              payloadAtlas = arraySize;
            }
            $lOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(67n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.mOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas = 0;
                payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadAtlas;
              }
              payloadAtlas = arraySize;
            }
            $mOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(68n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.nOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas = 0;
                payloadAtlas = 1;
                arraySize += payloadAtlas;
              }
              payloadAtlas = arraySize;
            }
            $nOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(69n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.oOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                payloadAtlas = payload.byteLength;
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $oOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(70n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.pOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                payloadAtlas = textEncoder.encode(payload);
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas.byteLength;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $pOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(71n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.qOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                elements.push(payloadAtlas);
                const payloadSize = (payloadAtlas as { $size: number }).$size;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $qOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(72n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.rOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                elements.push(payloadAtlas);
                const payloadSize = (payloadAtlas as { $size: number }).$size;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $rOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(73n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.sOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadAtlas = varintSizeFromValue(payload);
                  }
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $sOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(74n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.tOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                payloadAtlas = 8 * payload.length;
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $tOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(75n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.uOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas = 0;
                    payloadAtlas = varintSizeFromValue(payload);
                    arraySize += payloadAtlas;
                  }
                  payloadAtlas = arraySize;
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $uOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(76n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.vOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas = 0;
                    payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadAtlas;
                  }
                  payloadAtlas = arraySize;
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $vOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(77n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.wOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas = 0;
                    payloadAtlas = 1;
                    arraySize += payloadAtlas;
                  }
                  payloadAtlas = arraySize;
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $wOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(78n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.xOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let size = 0;
                  let elements = [];
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas;
                    payloadAtlas = payload.byteLength;
                    elements.push(payloadAtlas);
                    const payloadSize = payloadAtlas;
                    size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadAtlas = { $size: size, $elements: elements };
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas.$size;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $xOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(79n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.yOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let size = 0;
                  let elements = [];
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas;
                    payloadAtlas = textEncoder.encode(payload);
                    elements.push(payloadAtlas);
                    const payloadSize = payloadAtlas.byteLength;
                    size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadAtlas = { $size: size, $elements: elements };
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas.$size;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $yOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(80n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.zOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let size = 0;
                  let elements = [];
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas;
                    payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                    elements.push(payloadAtlas);
                    const payloadSize = (payloadAtlas as { $size: number }).$size;
                    size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadAtlas = { $size: size, $elements: elements };
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas.$size;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $zOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(81n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.aaOptional;
          if (payload !== undefined) {
            {
              let size = 0;
              let elements = [];
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                let payloadAtlas;
                {
                  let size = 0;
                  let elements = [];
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    let payloadAtlas;
                    payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                    elements.push(payloadAtlas);
                    const payloadSize = (payloadAtlas as { $size: number }).$size;
                    size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadAtlas = { $size: size, $elements: elements };
                }
                elements.push(payloadAtlas);
                const payloadSize = payloadAtlas.$size;
                size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadAtlas = { $size: size, $elements: elements };
            }
            $aaOptional = payloadAtlas;
            const payloadSize = payloadAtlas.$size;
            size += fieldHeaderSize(82n, payloadSize, false) + payloadSize;
          }
        }

        return {
          $size: size,
          aRequired: $aRequired,
          bRequired: $bRequired,
          cRequired: $cRequired,
          dRequired: $dRequired,
          eRequired: $eRequired,
          fRequired: $fRequired,
          gRequired: $gRequired,
          hRequired: $hRequired,
          iRequired: $iRequired,
          jRequired: $jRequired,
          kRequired: $kRequired,
          lRequired: $lRequired,
          mRequired: $mRequired,
          nRequired: $nRequired,
          oRequired: $oRequired,
          pRequired: $pRequired,
          qRequired: $qRequired,
          rRequired: $rRequired,
          sRequired: $sRequired,
          tRequired: $tRequired,
          uRequired: $uRequired,
          vRequired: $vRequired,
          wRequired: $wRequired,
          xRequired: $xRequired,
          yRequired: $yRequired,
          zRequired: $zRequired,
          aaRequired: $aaRequired,
          aAsymmetric: $aAsymmetric,
          bAsymmetric: $bAsymmetric,
          cAsymmetric: $cAsymmetric,
          dAsymmetric: $dAsymmetric,
          eAsymmetric: $eAsymmetric,
          fAsymmetric: $fAsymmetric,
          gAsymmetric: $gAsymmetric,
          hAsymmetric: $hAsymmetric,
          iAsymmetric: $iAsymmetric,
          jAsymmetric: $jAsymmetric,
          kAsymmetric: $kAsymmetric,
          lAsymmetric: $lAsymmetric,
          mAsymmetric: $mAsymmetric,
          nAsymmetric: $nAsymmetric,
          oAsymmetric: $oAsymmetric,
          pAsymmetric: $pAsymmetric,
          qAsymmetric: $qAsymmetric,
          rAsymmetric: $rAsymmetric,
          sAsymmetric: $sAsymmetric,
          tAsymmetric: $tAsymmetric,
          uAsymmetric: $uAsymmetric,
          vAsymmetric: $vAsymmetric,
          wAsymmetric: $wAsymmetric,
          xAsymmetric: $xAsymmetric,
          yAsymmetric: $yAsymmetric,
          zAsymmetric: $zAsymmetric,
          aaAsymmetric: $aaAsymmetric,
          aOptional: $aOptional,
          bOptional: $bOptional,
          cOptional: $cOptional,
          dOptional: $dOptional,
          eOptional: $eOptional,
          fOptional: $fOptional,
          gOptional: $gOptional,
          hOptional: $hOptional,
          iOptional: $iOptional,
          jOptional: $jOptional,
          kOptional: $kOptional,
          lOptional: $lOptional,
          mOptional: $mOptional,
          nOptional: $nOptional,
          oOptional: $oOptional,
          pOptional: $pOptional,
          qOptional: $qOptional,
          rOptional: $rOptional,
          sOptional: $sOptional,
          tOptional: $tOptional,
          uOptional: $uOptional,
          vOptional: $vOptional,
          wOptional: $wOptional,
          xOptional: $xOptional,
          yOptional: $yOptional,
          zOptional: $zOptional,
          aaOptional: $aaOptional,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: FooOut,
        atlas: FooAtlas,
      ): number {
        {
          const payload = message.aRequired;
          const payloadAtlas = atlas.aRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
        }

        {
          const payload = message.bRequired;
          const payloadAtlas = atlas.bRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          if (payloadAtlas !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
        }

        {
          const payload = message.cRequired;
          const payloadAtlas = atlas.cRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.dRequired;
          const payloadAtlas = atlas.dRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.eRequired;
          const payloadAtlas = atlas.eRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.fRequired;
          const payloadAtlas = atlas.fRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = message.gRequired;
          const payloadAtlas = atlas.gRequired;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.hRequired;
          const payloadAtlas = atlas.hRequired;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
        }

        {
          const payload = message.iRequired;
          const payloadAtlas = atlas.iRequired;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
        }

        {
          const payload = message.jRequired;
          const payloadAtlas = atlas.jRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.kRequired;
          const payloadAtlas = atlas.kRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
        }

        {
          const payload = message.lRequired;
          const payloadAtlas = atlas.lRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.mRequired;
          const payloadAtlas = atlas.mRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.nRequired;
          const payloadAtlas = atlas.nRequired;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.oRequired;
          const payloadAtlas = atlas.oRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
        }

        {
          const payload = message.pRequired;
          const payloadAtlas = atlas.pRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
              {
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(payloadAtlas, offset);
                offset += payloadAtlas.byteLength;
              }
            }
          }
        }

        {
          const payload = message.qRequired;
          const payloadAtlas = atlas.qRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
        }

        {
          const payload = message.rRequired;
          const payloadAtlas = atlas.rRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
        }

        {
          const payload = message.sRequired;
          const payloadAtlas = atlas.sRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.tRequired;
          const payloadAtlas = atlas.tRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
        }

        {
          const payload = message.uRequired;
          const payloadAtlas = atlas.uRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.vRequired;
          const payloadAtlas = atlas.vRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.wRequired;
          const payloadAtlas = atlas.wRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.xRequired;
          const payloadAtlas = atlas.xRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.yRequired;
          const payloadAtlas = atlas.yRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                  {
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(payloadAtlas, offset);
                    offset += payloadAtlas.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.zRequired;
          const payloadAtlas = atlas.zRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
        }

        {
          const payload = message.aaRequired;
          const payloadAtlas = atlas.aaRequired;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
        }

        {
          const payload = message.aAsymmetric;
          const payloadAtlas = atlas.aAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
        }

        {
          const payload = message.bAsymmetric;
          const payloadAtlas = atlas.bAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
          if (payloadAtlas !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
        }

        {
          const payload = message.cAsymmetric;
          const payloadAtlas = atlas.cAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.dAsymmetric;
          const payloadAtlas = atlas.dAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 31n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.eAsymmetric;
          const payloadAtlas = atlas.eAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.fAsymmetric;
          const payloadAtlas = atlas.fAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
        }

        {
          const payload = message.gAsymmetric;
          const payloadAtlas = atlas.gAsymmetric;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.hAsymmetric;
          const payloadAtlas = atlas.hAsymmetric;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
        }

        {
          const payload = message.iAsymmetric;
          const payloadAtlas = atlas.iAsymmetric;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
        }

        {
          const payload = message.jAsymmetric;
          const payloadAtlas = atlas.jAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = message.kAsymmetric;
          const payloadAtlas = atlas.kAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
        }

        {
          const payload = message.lAsymmetric;
          const payloadAtlas = atlas.lAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.mAsymmetric;
          const payloadAtlas = atlas.mAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.nAsymmetric;
          const payloadAtlas = atlas.nAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.oAsymmetric;
          const payloadAtlas = atlas.oAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
        }

        {
          const payload = message.pAsymmetric;
          const payloadAtlas = atlas.pAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
              {
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(payloadAtlas, offset);
                offset += payloadAtlas.byteLength;
              }
            }
          }
        }

        {
          const payload = message.qAsymmetric;
          const payloadAtlas = atlas.qAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
        }

        {
          const payload = message.rAsymmetric;
          const payloadAtlas = atlas.rAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
        }

        {
          const payload = message.sAsymmetric;
          const payloadAtlas = atlas.sAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.tAsymmetric;
          const payloadAtlas = atlas.tAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 47n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
        }

        {
          const payload = message.uAsymmetric;
          const payloadAtlas = atlas.uAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 48n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.vAsymmetric;
          const payloadAtlas = atlas.vAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 49n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.wAsymmetric;
          const payloadAtlas = atlas.wAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 50n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.xAsymmetric;
          const payloadAtlas = atlas.xAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 51n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.yAsymmetric;
          const payloadAtlas = atlas.yAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 52n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                  {
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(payloadAtlas, offset);
                    offset += payloadAtlas.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.zAsymmetric;
          const payloadAtlas = atlas.zAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 53n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
        }

        {
          const payload = message.aaAsymmetric;
          const payloadAtlas = atlas.aaAsymmetric;
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 54n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
        }

        {
          const payload = message.aOptional;
          const payloadAtlas = atlas.aOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 56n, payloadSize, false);
          }
        }

        {
          const payload = message.bOptional;
          const payloadAtlas = atlas.bOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 57n, payloadSize, false);
            if (payloadAtlas !== 0) {
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
        }

        {
          const payload = message.cOptional;
          const payloadAtlas = atlas.cOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 58n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.dOptional;
          const payloadAtlas = atlas.dOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 59n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.eOptional;
          const payloadAtlas = atlas.eOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 60n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.fOptional;
          const payloadAtlas = atlas.fOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 61n, payloadSize, false);
            {
              const sourceBuffer = new Uint8Array(payload);
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(sourceBuffer, offset);
              offset += sourceBuffer.byteLength;
            }
          }
        }

        {
          const payload = message.gOptional;
          const payloadAtlas = atlas.gOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 62n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.hOptional;
          const payloadAtlas = atlas.hOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = (payloadAtlas as { $size: number }).$size;
            offset = serializeFieldHeader(dataView, offset, 63n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          }
        }

        {
          const payload = message.iOptional;
          const payloadAtlas = atlas.iOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = (payloadAtlas as { $size: number }).$size;
            offset = serializeFieldHeader(dataView, offset, 64n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          }
        }

        {
          const payload = message.jOptional;
          const payloadAtlas = atlas.jOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 65n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = message.kOptional;
          const payloadAtlas = atlas.kOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 66n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                dataView.setFloat64(offset, payload, true);
                offset += 8;
              }
            }
          }
        }

        {
          const payload = message.lOptional;
          const payloadAtlas = atlas.lOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 67n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = message.mOptional;
          const payloadAtlas = atlas.mOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 68n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = message.nOptional;
          const payloadAtlas = atlas.nOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 69n, payloadSize, false);
            {
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = message.oOptional;
          const payloadAtlas = atlas.oOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 70n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                {
                  const sourceBuffer = new Uint8Array(payload);
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(sourceBuffer, offset);
                  offset += sourceBuffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = message.pOptional;
          const payloadAtlas = atlas.pOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 71n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                {
                  const targetBuffer = new Uint8Array(
                    dataView.buffer,
                    dataView.byteOffset,
                    dataView.byteLength,
                  );
                  targetBuffer.set(payloadAtlas, offset);
                  offset += payloadAtlas.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = message.qOptional;
          const payloadAtlas = atlas.qOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 72n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
              }
            }
          }
        }

        {
          const payload = message.rOptional;
          const payloadAtlas = atlas.rOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 73n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
              }
            }
          }
        }

        {
          const payload = message.sOptional;
          const payloadAtlas = atlas.sOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 74n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = message.tOptional;
          const payloadAtlas = atlas.tOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 75n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    dataView.setFloat64(offset, payload, true);
                    offset += 8;
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.uOptional;
          const payloadAtlas = atlas.uOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 76n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.vOptional;
          const payloadAtlas = atlas.vOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 77n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.wOptional;
          const payloadAtlas = atlas.wOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 78n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                {
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.xOptional;
          const payloadAtlas = atlas.xOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 79n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
                {
                  const oldPayload = payload;
                  const oldPayloadAtlas = payloadAtlas;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    const payloadAtlas = oldPayloadAtlas.$elements[i];
                    offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                    {
                      const sourceBuffer = new Uint8Array(payload);
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(sourceBuffer, offset);
                      offset += sourceBuffer.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.yOptional;
          const payloadAtlas = atlas.yOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 80n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
                {
                  const oldPayload = payload;
                  const oldPayloadAtlas = payloadAtlas;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    const payloadAtlas = oldPayloadAtlas.$elements[i];
                    offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                    {
                      const targetBuffer = new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset,
                        dataView.byteLength,
                      );
                      targetBuffer.set(payloadAtlas, offset);
                      offset += payloadAtlas.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.zOptional;
          const payloadAtlas = atlas.zOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 81n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
                {
                  const oldPayload = payload;
                  const oldPayloadAtlas = payloadAtlas;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    const payloadAtlas = oldPayloadAtlas.$elements[i];
                    offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                    offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                  }
                }
              }
            }
          }
        }

        {
          const payload = message.aaOptional;
          const payloadAtlas = atlas.aaOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.$size;
            offset = serializeFieldHeader(dataView, offset, 82n, payloadSize, false);
            {
              const oldPayload = payload;
              const oldPayloadAtlas = payloadAtlas;
              for (let i = 0; i < oldPayload.length; i += 1) {
                const payload = oldPayload[i];
                const payloadAtlas = oldPayloadAtlas.$elements[i];
                offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
                {
                  const oldPayload = payload;
                  const oldPayloadAtlas = payloadAtlas;
                  for (let i = 0; i < oldPayload.length; i += 1) {
                    const payload = oldPayload[i];
                    const payloadAtlas = oldPayloadAtlas.$elements[i];
                    offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                    offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                  }
                }
              }
            }
          }
        }

        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): FooIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $aRequired, $bRequired, $cRequired, $dRequired, $eRequired, $fRequired, $gRequired, $hRequired, $iRequired, $jRequired, $kRequired, $lRequired, $mRequired, $nRequired, $oRequired, $pRequired, $qRequired, $rRequired, $sRequired, $tRequired, $uRequired, $vRequired, $wRequired, $xRequired, $yRequired, $zRequired, $aaRequired, $aAsymmetric, $bAsymmetric, $cAsymmetric, $dAsymmetric, $eAsymmetric, $fAsymmetric, $gAsymmetric, $hAsymmetric, $iAsymmetric, $jAsymmetric, $kAsymmetric, $lAsymmetric, $mAsymmetric, $nAsymmetric, $oAsymmetric, $pAsymmetric, $qAsymmetric, $rAsymmetric, $sAsymmetric, $tAsymmetric, $uAsymmetric, $vAsymmetric, $wAsymmetric, $xAsymmetric, $yAsymmetric, $zAsymmetric, $aaAsymmetric, $aOptional, $bOptional, $cOptional, $dOptional, $eOptional, $fOptional, $gOptional, $hOptional, $iOptional, $jOptional, $kOptional, $lOptional, $mOptional, $nOptional, $oOptional, $pOptional, $qOptional, $rOptional, $sOptional, $tOptional, $uOptional, $vOptional, $wOptional, $xOptional, $yOptional, $zOptional, $aaOptional;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $aRequired = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              $bRequired = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              $cRequired = payload;
              break;
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              $dRequired = payload;
              break;
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $eRequired = payload;
              break;
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fRequired = payload;
              break;
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $gRequired = payload;
              break;
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $hRequired = payload;
              break;
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $iRequired = payload;
              break;
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $jRequired = payload;
              break;
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $kRequired = payload;
              break;
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $lRequired = payload;
              break;
            }
            case 12n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $mRequired = payload;
              break;
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $nRequired = payload;
              break;
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $oRequired = payload;
              break;
            }
            case 15n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $pRequired = payload;
              break;
            }
            case 16n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $qRequired = payload;
              break;
            }
            case 17n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $rRequired = payload;
              break;
            }
            case 18n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $sRequired = payload;
              break;
            }
            case 19n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $tRequired = payload;
              break;
            }
            case 20n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $uRequired = payload;
              break;
            }
            case 21n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $vRequired = payload;
              break;
            }
            case 22n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $wRequired = payload;
              break;
            }
            case 23n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $xRequired = payload;
              break;
            }
            case 24n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $yRequired = payload;
              break;
            }
            case 25n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $zRequired = payload;
              break;
            }
            case 26n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $aaRequired = payload;
              break;
            }
            case 28n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $aAsymmetric = payload;
              break;
            }
            case 29n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              $bAsymmetric = payload;
              break;
            }
            case 30n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              $cAsymmetric = payload;
              break;
            }
            case 31n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              $dAsymmetric = payload;
              break;
            }
            case 32n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $eAsymmetric = payload;
              break;
            }
            case 33n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fAsymmetric = payload;
              break;
            }
            case 34n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $gAsymmetric = payload;
              break;
            }
            case 35n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $hAsymmetric = payload;
              break;
            }
            case 36n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $iAsymmetric = payload;
              break;
            }
            case 37n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $jAsymmetric = payload;
              break;
            }
            case 38n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $kAsymmetric = payload;
              break;
            }
            case 39n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $lAsymmetric = payload;
              break;
            }
            case 40n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $mAsymmetric = payload;
              break;
            }
            case 41n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $nAsymmetric = payload;
              break;
            }
            case 42n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $oAsymmetric = payload;
              break;
            }
            case 43n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $pAsymmetric = payload;
              break;
            }
            case 44n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $qAsymmetric = payload;
              break;
            }
            case 45n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $rAsymmetric = payload;
              break;
            }
            case 46n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $sAsymmetric = payload;
              break;
            }
            case 47n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $tAsymmetric = payload;
              break;
            }
            case 48n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $uAsymmetric = payload;
              break;
            }
            case 49n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $vAsymmetric = payload;
              break;
            }
            case 50n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $wAsymmetric = payload;
              break;
            }
            case 51n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $xAsymmetric = payload;
              break;
            }
            case 52n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $yAsymmetric = payload;
              break;
            }
            case 53n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $zAsymmetric = payload;
              break;
            }
            case 54n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $aaAsymmetric = payload;
              break;
            }
            case 56n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $aOptional = payload;
              break;
            }
            case 57n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              $bOptional = payload;
              break;
            }
            case 58n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              $cOptional = payload;
              break;
            }
            case 59n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              $dOptional = payload;
              break;
            }
            case 60n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $eOptional = payload;
              break;
            }
            case 61n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $fOptional = payload;
              break;
            }
            case 62n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $gOptional = payload;
              break;
            }
            case 63n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $hOptional = payload;
              break;
            }
            case 64n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              $iOptional = payload;
              break;
            }
            case 65n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              $jOptional = payload;
              break;
            }
            case 66n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $kOptional = payload;
              break;
            }
            case 67n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $lOptional = payload;
              break;
            }
            case 68n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $mOptional = payload;
              break;
            }
            case 69n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              $nOptional = payload;
              break;
            }
            case 70n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $oOptional = payload;
              break;
            }
            case 71n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $pOptional = payload;
              break;
            }
            case 72n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $qOptional = payload;
              break;
            }
            case 73n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $rOptional = payload;
              break;
            }
            case 74n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $sOptional = payload;
              break;
            }
            case 75n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $tOptional = payload;
              break;
            }
            case 76n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $uOptional = payload;
              break;
            }
            case 77n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $vOptional = payload;
              break;
            }
            case 78n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $wOptional = payload;
              break;
            }
            case 79n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $xOptional = payload;
              break;
            }
            case 80n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $yOptional = payload;
              break;
            }
            case 81n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $zOptional = payload;
              break;
            }
            case 82n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              $aaOptional = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($aRequired === undefined
          || $bRequired === undefined
          || $cRequired === undefined
          || $dRequired === undefined
          || $eRequired === undefined
          || $fRequired === undefined
          || $gRequired === undefined
          || $hRequired === undefined
          || $iRequired === undefined
          || $jRequired === undefined
          || $kRequired === undefined
          || $lRequired === undefined
          || $mRequired === undefined
          || $nRequired === undefined
          || $oRequired === undefined
          || $pRequired === undefined
          || $qRequired === undefined
          || $rRequired === undefined
          || $sRequired === undefined
          || $tRequired === undefined
          || $uRequired === undefined
          || $vRequired === undefined
          || $wRequired === undefined
          || $xRequired === undefined
          || $yRequired === undefined
          || $zRequired === undefined
          || $aaRequired === undefined) {
          throw new Error(missingFieldsErrorMessage);
        }

        return {
          aRequired: $aRequired,
          bRequired: $bRequired,
          cRequired: $cRequired,
          dRequired: $dRequired,
          eRequired: $eRequired,
          fRequired: $fRequired,
          gRequired: $gRequired,
          hRequired: $hRequired,
          iRequired: $iRequired,
          jRequired: $jRequired,
          kRequired: $kRequired,
          lRequired: $lRequired,
          mRequired: $mRequired,
          nRequired: $nRequired,
          oRequired: $oRequired,
          pRequired: $pRequired,
          qRequired: $qRequired,
          rRequired: $rRequired,
          sRequired: $sRequired,
          tRequired: $tRequired,
          uRequired: $uRequired,
          vRequired: $vRequired,
          wRequired: $wRequired,
          xRequired: $xRequired,
          yRequired: $yRequired,
          zRequired: $zRequired,
          aaRequired: $aaRequired,
          aAsymmetric: $aAsymmetric,
          bAsymmetric: $bAsymmetric,
          cAsymmetric: $cAsymmetric,
          dAsymmetric: $dAsymmetric,
          eAsymmetric: $eAsymmetric,
          fAsymmetric: $fAsymmetric,
          gAsymmetric: $gAsymmetric,
          hAsymmetric: $hAsymmetric,
          iAsymmetric: $iAsymmetric,
          jAsymmetric: $jAsymmetric,
          kAsymmetric: $kAsymmetric,
          lAsymmetric: $lAsymmetric,
          mAsymmetric: $mAsymmetric,
          nAsymmetric: $nAsymmetric,
          oAsymmetric: $oAsymmetric,
          pAsymmetric: $pAsymmetric,
          qAsymmetric: $qAsymmetric,
          rAsymmetric: $rAsymmetric,
          sAsymmetric: $sAsymmetric,
          tAsymmetric: $tAsymmetric,
          uAsymmetric: $uAsymmetric,
          vAsymmetric: $vAsymmetric,
          wAsymmetric: $wAsymmetric,
          xAsymmetric: $xAsymmetric,
          yAsymmetric: $yAsymmetric,
          zAsymmetric: $zAsymmetric,
          aaAsymmetric: $aaAsymmetric,
          aOptional: $aOptional,
          bOptional: $bOptional,
          cOptional: $cOptional,
          dOptional: $dOptional,
          eOptional: $eOptional,
          fOptional: $fOptional,
          gOptional: $gOptional,
          hOptional: $hOptional,
          iOptional: $iOptional,
          jOptional: $jOptional,
          kOptional: $kOptional,
          lOptional: $lOptional,
          mOptional: $mOptional,
          nOptional: $nOptional,
          oOptional: $oOptional,
          pOptional: $pOptional,
          qOptional: $qOptional,
          rOptional: $rOptional,
          sOptional: $sOptional,
          tOptional: $tOptional,
          uOptional: $uOptional,
          vOptional: $vOptional,
          wOptional: $wOptional,
          xOptional: $xOptional,
          yOptional: $yOptional,
          zOptional: $zOptional,
          aaOptional: $aaOptional,
        };
      }
    }

    export type BarAtlas =
      | { $size: number; aRequired: number }
      | { $size: number; bRequired: number }
      | { $size: number; cRequired: number }
      | { $size: number; dRequired: number }
      | { $size: number; eRequired: number }
      | { $size: number; fRequired: number }
      | { $size: number; gRequired: Uint8Array }
      | { $size: number; hRequired: Comprehensive.Types.LocalStructAtlas }
      | { $size: number; iRequired: Degenerate.Types.EmptyStructAtlas }
      | { $size: number; jRequired: number }
      | { $size: number; kRequired: number }
      | { $size: number; lRequired: number }
      | { $size: number; mRequired: number }
      | { $size: number; nRequired: number }
      | { $size: number; oRequired: { $size: number; $elements: number[] } }
      | { $size: number; pRequired: { $size: number; $elements: Uint8Array[] } }
      | { $size: number; qRequired: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] } }
      | { $size: number; rRequired: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] } }
      | { $size: number; sRequired: { $size: number; $elements: number[] } }
      | { $size: number; tRequired: { $size: number; $elements: number[] } }
      | { $size: number; uRequired: { $size: number; $elements: number[] } }
      | { $size: number; vRequired: { $size: number; $elements: number[] } }
      | { $size: number; wRequired: { $size: number; $elements: number[] } }
      | { $size: number; xRequired: { $size: number; $elements: { $size: number; $elements: number[] }[] } }
      | { $size: number; yRequired: { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] } }
      | { $size: number; zRequired: { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] } }
      | { $size: number; aaRequired: { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] } }
      | { $size: number; aAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; bAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; cAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; dAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; eAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; fAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; gAsymmetric: Uint8Array; $fallback: BarAtlas }
      | { $size: number; hAsymmetric: Comprehensive.Types.LocalStructAtlas; $fallback: BarAtlas }
      | { $size: number; iAsymmetric: Degenerate.Types.EmptyStructAtlas; $fallback: BarAtlas }
      | { $size: number; jAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; kAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; lAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; mAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; nAsymmetric: number; $fallback: BarAtlas }
      | { $size: number; oAsymmetric: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; pAsymmetric: { $size: number; $elements: Uint8Array[] }; $fallback: BarAtlas }
      | { $size: number; qAsymmetric: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }; $fallback: BarAtlas }
      | { $size: number; rAsymmetric: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }; $fallback: BarAtlas }
      | { $size: number; sAsymmetric: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; tAsymmetric: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; uAsymmetric: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; vAsymmetric: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; wAsymmetric: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; xAsymmetric: { $size: number; $elements: { $size: number; $elements: number[] }[] }; $fallback: BarAtlas }
      | { $size: number; yAsymmetric: { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] }; $fallback: BarAtlas }
      | { $size: number; zAsymmetric: { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] }; $fallback: BarAtlas }
      | { $size: number; aaAsymmetric: { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] }; $fallback: BarAtlas }
      | { $size: number; aOptional: number; $fallback: BarAtlas }
      | { $size: number; bOptional: number; $fallback: BarAtlas }
      | { $size: number; cOptional: number; $fallback: BarAtlas }
      | { $size: number; dOptional: number; $fallback: BarAtlas }
      | { $size: number; eOptional: number; $fallback: BarAtlas }
      | { $size: number; fOptional: number; $fallback: BarAtlas }
      | { $size: number; gOptional: Uint8Array; $fallback: BarAtlas }
      | { $size: number; hOptional: Comprehensive.Types.LocalStructAtlas; $fallback: BarAtlas }
      | { $size: number; iOptional: Degenerate.Types.EmptyStructAtlas; $fallback: BarAtlas }
      | { $size: number; jOptional: number; $fallback: BarAtlas }
      | { $size: number; kOptional: number; $fallback: BarAtlas }
      | { $size: number; lOptional: number; $fallback: BarAtlas }
      | { $size: number; mOptional: number; $fallback: BarAtlas }
      | { $size: number; nOptional: number; $fallback: BarAtlas }
      | { $size: number; oOptional: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; pOptional: { $size: number; $elements: Uint8Array[] }; $fallback: BarAtlas }
      | { $size: number; qOptional: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }; $fallback: BarAtlas }
      | { $size: number; rOptional: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }; $fallback: BarAtlas }
      | { $size: number; sOptional: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; tOptional: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; uOptional: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; vOptional: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; wOptional: { $size: number; $elements: number[] }; $fallback: BarAtlas }
      | { $size: number; xOptional: { $size: number; $elements: { $size: number; $elements: number[] }[] }; $fallback: BarAtlas }
      | { $size: number; yOptional: { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] }; $fallback: BarAtlas }
      | { $size: number; zOptional: { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] }; $fallback: BarAtlas }
      | { $size: number; aaOptional: { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] }; $fallback: BarAtlas };

    export type BarOut =
      | { aRequired: null }
      | { bRequired: number }
      | { cRequired: bigint }
      | { dRequired: bigint }
      | { eRequired: boolean }
      | { fRequired: ArrayBuffer }
      | { gRequired: string }
      | { hRequired: Comprehensive.Types.LocalStructOut }
      | { iRequired: Degenerate.Types.EmptyStructOut }
      | { jRequired: null[] }
      | { kRequired: number[] }
      | { lRequired: bigint[] }
      | { mRequired: bigint[] }
      | { nRequired: boolean[] }
      | { oRequired: ArrayBuffer[] }
      | { pRequired: string[] }
      | { qRequired: Comprehensive.Types.LocalStructOut[] }
      | { rRequired: Degenerate.Types.EmptyStructOut[] }
      | { sRequired: null[][] }
      | { tRequired: number[][] }
      | { uRequired: bigint[][] }
      | { vRequired: bigint[][] }
      | { wRequired: boolean[][] }
      | { xRequired: ArrayBuffer[][] }
      | { yRequired: string[][] }
      | { zRequired: Comprehensive.Types.LocalStructOut[][] }
      | { aaRequired: Degenerate.Types.EmptyStructOut[][] }
      | { aAsymmetric: null; $fallback: BarOut }
      | { bAsymmetric: number; $fallback: BarOut }
      | { cAsymmetric: bigint; $fallback: BarOut }
      | { dAsymmetric: bigint; $fallback: BarOut }
      | { eAsymmetric: boolean; $fallback: BarOut }
      | { fAsymmetric: ArrayBuffer; $fallback: BarOut }
      | { gAsymmetric: string; $fallback: BarOut }
      | { hAsymmetric: Comprehensive.Types.LocalStructOut; $fallback: BarOut }
      | { iAsymmetric: Degenerate.Types.EmptyStructOut; $fallback: BarOut }
      | { jAsymmetric: null[]; $fallback: BarOut }
      | { kAsymmetric: number[]; $fallback: BarOut }
      | { lAsymmetric: bigint[]; $fallback: BarOut }
      | { mAsymmetric: bigint[]; $fallback: BarOut }
      | { nAsymmetric: boolean[]; $fallback: BarOut }
      | { oAsymmetric: ArrayBuffer[]; $fallback: BarOut }
      | { pAsymmetric: string[]; $fallback: BarOut }
      | { qAsymmetric: Comprehensive.Types.LocalStructOut[]; $fallback: BarOut }
      | { rAsymmetric: Degenerate.Types.EmptyStructOut[]; $fallback: BarOut }
      | { sAsymmetric: null[][]; $fallback: BarOut }
      | { tAsymmetric: number[][]; $fallback: BarOut }
      | { uAsymmetric: bigint[][]; $fallback: BarOut }
      | { vAsymmetric: bigint[][]; $fallback: BarOut }
      | { wAsymmetric: boolean[][]; $fallback: BarOut }
      | { xAsymmetric: ArrayBuffer[][]; $fallback: BarOut }
      | { yAsymmetric: string[][]; $fallback: BarOut }
      | { zAsymmetric: Comprehensive.Types.LocalStructOut[][]; $fallback: BarOut }
      | { aaAsymmetric: Degenerate.Types.EmptyStructOut[][]; $fallback: BarOut }
      | { aOptional: null; $fallback: BarOut }
      | { bOptional: number; $fallback: BarOut }
      | { cOptional: bigint; $fallback: BarOut }
      | { dOptional: bigint; $fallback: BarOut }
      | { eOptional: boolean; $fallback: BarOut }
      | { fOptional: ArrayBuffer; $fallback: BarOut }
      | { gOptional: string; $fallback: BarOut }
      | { hOptional: Comprehensive.Types.LocalStructOut; $fallback: BarOut }
      | { iOptional: Degenerate.Types.EmptyStructOut; $fallback: BarOut }
      | { jOptional: null[]; $fallback: BarOut }
      | { kOptional: number[]; $fallback: BarOut }
      | { lOptional: bigint[]; $fallback: BarOut }
      | { mOptional: bigint[]; $fallback: BarOut }
      | { nOptional: boolean[]; $fallback: BarOut }
      | { oOptional: ArrayBuffer[]; $fallback: BarOut }
      | { pOptional: string[]; $fallback: BarOut }
      | { qOptional: Comprehensive.Types.LocalStructOut[]; $fallback: BarOut }
      | { rOptional: Degenerate.Types.EmptyStructOut[]; $fallback: BarOut }
      | { sOptional: null[][]; $fallback: BarOut }
      | { tOptional: number[][]; $fallback: BarOut }
      | { uOptional: bigint[][]; $fallback: BarOut }
      | { vOptional: bigint[][]; $fallback: BarOut }
      | { wOptional: boolean[][]; $fallback: BarOut }
      | { xOptional: ArrayBuffer[][]; $fallback: BarOut }
      | { yOptional: string[][]; $fallback: BarOut }
      | { zOptional: Comprehensive.Types.LocalStructOut[][]; $fallback: BarOut }
      | { aaOptional: Degenerate.Types.EmptyStructOut[][]; $fallback: BarOut };

    export type BarIn =
      | { $field: 'aRequired'; aRequired: null }
      | { $field: 'bRequired'; bRequired: number }
      | { $field: 'cRequired'; cRequired: bigint }
      | { $field: 'dRequired'; dRequired: bigint }
      | { $field: 'eRequired'; eRequired: boolean }
      | { $field: 'fRequired'; fRequired: ArrayBuffer }
      | { $field: 'gRequired'; gRequired: string }
      | { $field: 'hRequired'; hRequired: Comprehensive.Types.LocalStructIn }
      | { $field: 'iRequired'; iRequired: Degenerate.Types.EmptyStructIn }
      | { $field: 'jRequired'; jRequired: null[] }
      | { $field: 'kRequired'; kRequired: number[] }
      | { $field: 'lRequired'; lRequired: bigint[] }
      | { $field: 'mRequired'; mRequired: bigint[] }
      | { $field: 'nRequired'; nRequired: boolean[] }
      | { $field: 'oRequired'; oRequired: ArrayBuffer[] }
      | { $field: 'pRequired'; pRequired: string[] }
      | { $field: 'qRequired'; qRequired: Comprehensive.Types.LocalStructIn[] }
      | { $field: 'rRequired'; rRequired: Degenerate.Types.EmptyStructIn[] }
      | { $field: 'sRequired'; sRequired: null[][] }
      | { $field: 'tRequired'; tRequired: number[][] }
      | { $field: 'uRequired'; uRequired: bigint[][] }
      | { $field: 'vRequired'; vRequired: bigint[][] }
      | { $field: 'wRequired'; wRequired: boolean[][] }
      | { $field: 'xRequired'; xRequired: ArrayBuffer[][] }
      | { $field: 'yRequired'; yRequired: string[][] }
      | { $field: 'zRequired'; zRequired: Comprehensive.Types.LocalStructIn[][] }
      | { $field: 'aaRequired'; aaRequired: Degenerate.Types.EmptyStructIn[][] }
      | { $field: 'aAsymmetric'; aAsymmetric: null }
      | { $field: 'bAsymmetric'; bAsymmetric: number }
      | { $field: 'cAsymmetric'; cAsymmetric: bigint }
      | { $field: 'dAsymmetric'; dAsymmetric: bigint }
      | { $field: 'eAsymmetric'; eAsymmetric: boolean }
      | { $field: 'fAsymmetric'; fAsymmetric: ArrayBuffer }
      | { $field: 'gAsymmetric'; gAsymmetric: string }
      | { $field: 'hAsymmetric'; hAsymmetric: Comprehensive.Types.LocalStructIn }
      | { $field: 'iAsymmetric'; iAsymmetric: Degenerate.Types.EmptyStructIn }
      | { $field: 'jAsymmetric'; jAsymmetric: null[] }
      | { $field: 'kAsymmetric'; kAsymmetric: number[] }
      | { $field: 'lAsymmetric'; lAsymmetric: bigint[] }
      | { $field: 'mAsymmetric'; mAsymmetric: bigint[] }
      | { $field: 'nAsymmetric'; nAsymmetric: boolean[] }
      | { $field: 'oAsymmetric'; oAsymmetric: ArrayBuffer[] }
      | { $field: 'pAsymmetric'; pAsymmetric: string[] }
      | { $field: 'qAsymmetric'; qAsymmetric: Comprehensive.Types.LocalStructIn[] }
      | { $field: 'rAsymmetric'; rAsymmetric: Degenerate.Types.EmptyStructIn[] }
      | { $field: 'sAsymmetric'; sAsymmetric: null[][] }
      | { $field: 'tAsymmetric'; tAsymmetric: number[][] }
      | { $field: 'uAsymmetric'; uAsymmetric: bigint[][] }
      | { $field: 'vAsymmetric'; vAsymmetric: bigint[][] }
      | { $field: 'wAsymmetric'; wAsymmetric: boolean[][] }
      | { $field: 'xAsymmetric'; xAsymmetric: ArrayBuffer[][] }
      | { $field: 'yAsymmetric'; yAsymmetric: string[][] }
      | { $field: 'zAsymmetric'; zAsymmetric: Comprehensive.Types.LocalStructIn[][] }
      | { $field: 'aaAsymmetric'; aaAsymmetric: Degenerate.Types.EmptyStructIn[][] }
      | { $field: 'aOptional'; aOptional: null; $fallback: BarIn }
      | { $field: 'bOptional'; bOptional: number; $fallback: BarIn }
      | { $field: 'cOptional'; cOptional: bigint; $fallback: BarIn }
      | { $field: 'dOptional'; dOptional: bigint; $fallback: BarIn }
      | { $field: 'eOptional'; eOptional: boolean; $fallback: BarIn }
      | { $field: 'fOptional'; fOptional: ArrayBuffer; $fallback: BarIn }
      | { $field: 'gOptional'; gOptional: string; $fallback: BarIn }
      | { $field: 'hOptional'; hOptional: Comprehensive.Types.LocalStructIn; $fallback: BarIn }
      | { $field: 'iOptional'; iOptional: Degenerate.Types.EmptyStructIn; $fallback: BarIn }
      | { $field: 'jOptional'; jOptional: null[]; $fallback: BarIn }
      | { $field: 'kOptional'; kOptional: number[]; $fallback: BarIn }
      | { $field: 'lOptional'; lOptional: bigint[]; $fallback: BarIn }
      | { $field: 'mOptional'; mOptional: bigint[]; $fallback: BarIn }
      | { $field: 'nOptional'; nOptional: boolean[]; $fallback: BarIn }
      | { $field: 'oOptional'; oOptional: ArrayBuffer[]; $fallback: BarIn }
      | { $field: 'pOptional'; pOptional: string[]; $fallback: BarIn }
      | { $field: 'qOptional'; qOptional: Comprehensive.Types.LocalStructIn[]; $fallback: BarIn }
      | { $field: 'rOptional'; rOptional: Degenerate.Types.EmptyStructIn[]; $fallback: BarIn }
      | { $field: 'sOptional'; sOptional: null[][]; $fallback: BarIn }
      | { $field: 'tOptional'; tOptional: number[][]; $fallback: BarIn }
      | { $field: 'uOptional'; uOptional: bigint[][]; $fallback: BarIn }
      | { $field: 'vOptional'; vOptional: bigint[][]; $fallback: BarIn }
      | { $field: 'wOptional'; wOptional: boolean[][]; $fallback: BarIn }
      | { $field: 'xOptional'; xOptional: ArrayBuffer[][]; $fallback: BarIn }
      | { $field: 'yOptional'; yOptional: string[][]; $fallback: BarIn }
      | { $field: 'zOptional'; zOptional: Comprehensive.Types.LocalStructIn[][]; $fallback: BarIn }
      | { $field: 'aaOptional'; aaOptional: Degenerate.Types.EmptyStructIn[][]; $fallback: BarIn };

    export namespace Bar {
      export function size(message: BarOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: BarOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): BarIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: BarOut): BarAtlas {
        if ('aRequired' in message) {
          let payloadAtlas;
          const payload = message.aRequired;
          payloadAtlas = 0;
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(0n, payloadSize, false) + payloadSize, aRequired: payloadAtlas };
        }
        if ('bRequired' in message) {
          let payloadAtlas;
          const payload = message.bRequired;
          if (Object.is(payload, 0)) {
            payloadAtlas = 0;
          } else {
            payloadAtlas = 8;
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(1n, payloadSize, false) + payloadSize, bRequired: payloadAtlas };
        }
        if ('cRequired' in message) {
          let payloadAtlas;
          const payload = message.cRequired;
          if (payload === 0n) {
            payloadAtlas = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadAtlas = varintSizeFromValue(payload);
          } else {
            payloadAtlas = 8;
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(2n, payloadSize, true) + payloadSize, cRequired: payloadAtlas };
        }
        if ('dRequired' in message) {
          let payloadAtlas;
          const payload = message.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadAtlas = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadAtlas = varintSizeFromValue(zigzag);
            } else {
              payloadAtlas = 8;
            }
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(3n, payloadSize, true) + payloadSize, dRequired: payloadAtlas };
        }
        if ('eRequired' in message) {
          let payloadAtlas;
          const payload = message.eRequired;
          if (payload) {
            payloadAtlas = 1;
          } else {
            payloadAtlas = 0;
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(4n, payloadSize, true) + payloadSize, eRequired: payloadAtlas };
        }
        if ('fRequired' in message) {
          let payloadAtlas;
          const payload = message.fRequired;
          payloadAtlas = payload.byteLength;
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(5n, payloadSize, false) + payloadSize, fRequired: payloadAtlas };
        }
        if ('gRequired' in message) {
          let payloadAtlas;
          const payload = message.gRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(6n, payloadSize, false) + payloadSize, gRequired: payloadAtlas };
        }
        if ('hRequired' in message) {
          let payloadAtlas;
          const payload = message.hRequired;
          payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          return { $size: fieldHeaderSize(7n, payloadSize, false) + payloadSize, hRequired: payloadAtlas };
        }
        if ('iRequired' in message) {
          let payloadAtlas;
          const payload = message.iRequired;
          payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          return { $size: fieldHeaderSize(8n, payloadSize, false) + payloadSize, iRequired: payloadAtlas };
        }
        if ('jRequired' in message) {
          let payloadAtlas;
          const payload = message.jRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadAtlas = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadAtlas = varintSizeFromValue(payload);
              } else {
                payloadAtlas = 8;
              }
            }
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(9n, payloadSize, false) + payloadSize, jRequired: payloadAtlas };
        }
        if ('kRequired' in message) {
          let payloadAtlas;
          const payload = message.kRequired;
          payloadAtlas = 8 * payload.length;
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(10n, payloadSize, false) + payloadSize, kRequired: payloadAtlas };
        }
        if ('lRequired' in message) {
          let payloadAtlas;
          const payload = message.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(payload);
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(11n, payloadSize, false) + payloadSize, lRequired: payloadAtlas };
        }
        if ('mRequired' in message) {
          let payloadAtlas;
          const payload = message.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(12n, payloadSize, false) + payloadSize, mRequired: payloadAtlas };
        }
        if ('nRequired' in message) {
          let payloadAtlas;
          const payload = message.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = 1;
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(13n, payloadSize, false) + payloadSize, nRequired: payloadAtlas };
        }
        if ('oRequired' in message) {
          let payloadAtlas;
          const payload = message.oRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = payload.byteLength;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(14n, payloadSize, false) + payloadSize, oRequired: payloadAtlas };
        }
        if ('pRequired' in message) {
          let payloadAtlas;
          const payload = message.pRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = textEncoder.encode(payload);
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.byteLength;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(15n, payloadSize, false) + payloadSize, pRequired: payloadAtlas };
        }
        if ('qRequired' in message) {
          let payloadAtlas;
          const payload = message.qRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(16n, payloadSize, false) + payloadSize, qRequired: payloadAtlas };
        }
        if ('rRequired' in message) {
          let payloadAtlas;
          const payload = message.rRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(17n, payloadSize, false) + payloadSize, rRequired: payloadAtlas };
        }
        if ('sRequired' in message) {
          let payloadAtlas;
          const payload = message.sRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadAtlas = varintSizeFromValue(payload);
                }
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(18n, payloadSize, false) + payloadSize, sRequired: payloadAtlas };
        }
        if ('tRequired' in message) {
          let payloadAtlas;
          const payload = message.tRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = 8 * payload.length;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(19n, payloadSize, false) + payloadSize, tRequired: payloadAtlas };
        }
        if ('uRequired' in message) {
          let payloadAtlas;
          const payload = message.uRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(payload);
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(20n, payloadSize, false) + payloadSize, uRequired: payloadAtlas };
        }
        if ('vRequired' in message) {
          let payloadAtlas;
          const payload = message.vRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(21n, payloadSize, false) + payloadSize, vRequired: payloadAtlas };
        }
        if ('wRequired' in message) {
          let payloadAtlas;
          const payload = message.wRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = 1;
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(22n, payloadSize, false) + payloadSize, wRequired: payloadAtlas };
        }
        if ('xRequired' in message) {
          let payloadAtlas;
          const payload = message.xRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = payload.byteLength;
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(23n, payloadSize, false) + payloadSize, xRequired: payloadAtlas };
        }
        if ('yRequired' in message) {
          let payloadAtlas;
          const payload = message.yRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = textEncoder.encode(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas.byteLength;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(24n, payloadSize, false) + payloadSize, yRequired: payloadAtlas };
        }
        if ('zRequired' in message) {
          let payloadAtlas;
          const payload = message.zRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(25n, payloadSize, false) + payloadSize, zRequired: payloadAtlas };
        }
        if ('aaRequired' in message) {
          let payloadAtlas;
          const payload = message.aaRequired;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          return { $size: fieldHeaderSize(26n, payloadSize, false) + payloadSize, aaRequired: payloadAtlas };
        }
        if ('aAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.aAsymmetric;
          payloadAtlas = 0;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(28n, payloadSize, false) + payloadSize + fallbackAtlas.$size, aAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('bAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.bAsymmetric;
          if (Object.is(payload, 0)) {
            payloadAtlas = 0;
          } else {
            payloadAtlas = 8;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(29n, payloadSize, false) + payloadSize + fallbackAtlas.$size, bAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('cAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.cAsymmetric;
          if (payload === 0n) {
            payloadAtlas = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadAtlas = varintSizeFromValue(payload);
          } else {
            payloadAtlas = 8;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(30n, payloadSize, true) + payloadSize + fallbackAtlas.$size, cAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('dAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadAtlas = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadAtlas = varintSizeFromValue(zigzag);
            } else {
              payloadAtlas = 8;
            }
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(31n, payloadSize, true) + payloadSize + fallbackAtlas.$size, dAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('eAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.eAsymmetric;
          if (payload) {
            payloadAtlas = 1;
          } else {
            payloadAtlas = 0;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(32n, payloadSize, true) + payloadSize + fallbackAtlas.$size, eAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('fAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.fAsymmetric;
          payloadAtlas = payload.byteLength;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(33n, payloadSize, false) + payloadSize + fallbackAtlas.$size, fAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('gAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.gAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(34n, payloadSize, false) + payloadSize + fallbackAtlas.$size, gAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('hAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.hAsymmetric;
          payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(35n, payloadSize, false) + payloadSize + fallbackAtlas.$size, hAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('iAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.iAsymmetric;
          payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(36n, payloadSize, false) + payloadSize + fallbackAtlas.$size, iAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('jAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.jAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadAtlas = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadAtlas = varintSizeFromValue(payload);
              } else {
                payloadAtlas = 8;
              }
            }
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(37n, payloadSize, false) + payloadSize + fallbackAtlas.$size, jAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('kAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.kAsymmetric;
          payloadAtlas = 8 * payload.length;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(38n, payloadSize, false) + payloadSize + fallbackAtlas.$size, kAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('lAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(payload);
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(39n, payloadSize, false) + payloadSize + fallbackAtlas.$size, lAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('mAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(40n, payloadSize, false) + payloadSize + fallbackAtlas.$size, mAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('nAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = 1;
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(41n, payloadSize, false) + payloadSize + fallbackAtlas.$size, nAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('oAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.oAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = payload.byteLength;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(42n, payloadSize, false) + payloadSize + fallbackAtlas.$size, oAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('pAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.pAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = textEncoder.encode(payload);
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.byteLength;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(43n, payloadSize, false) + payloadSize + fallbackAtlas.$size, pAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('qAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.qAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(44n, payloadSize, false) + payloadSize + fallbackAtlas.$size, qAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('rAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.rAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(45n, payloadSize, false) + payloadSize + fallbackAtlas.$size, rAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('sAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.sAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadAtlas = varintSizeFromValue(payload);
                }
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(46n, payloadSize, false) + payloadSize + fallbackAtlas.$size, sAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('tAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.tAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = 8 * payload.length;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(47n, payloadSize, false) + payloadSize + fallbackAtlas.$size, tAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('uAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.uAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(payload);
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(48n, payloadSize, false) + payloadSize + fallbackAtlas.$size, uAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('vAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.vAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(49n, payloadSize, false) + payloadSize + fallbackAtlas.$size, vAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('wAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.wAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = 1;
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(50n, payloadSize, false) + payloadSize + fallbackAtlas.$size, wAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('xAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.xAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = payload.byteLength;
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(51n, payloadSize, false) + payloadSize + fallbackAtlas.$size, xAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('yAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.yAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = textEncoder.encode(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas.byteLength;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(52n, payloadSize, false) + payloadSize + fallbackAtlas.$size, yAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('zAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.zAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(53n, payloadSize, false) + payloadSize + fallbackAtlas.$size, zAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('aaAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.aaAsymmetric;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(54n, payloadSize, false) + payloadSize + fallbackAtlas.$size, aaAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('aOptional' in message) {
          let payloadAtlas;
          const payload = message.aOptional;
          payloadAtlas = 0;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(56n, payloadSize, false) + payloadSize + fallbackAtlas.$size, aOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('bOptional' in message) {
          let payloadAtlas;
          const payload = message.bOptional;
          if (Object.is(payload, 0)) {
            payloadAtlas = 0;
          } else {
            payloadAtlas = 8;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(57n, payloadSize, false) + payloadSize + fallbackAtlas.$size, bOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('cOptional' in message) {
          let payloadAtlas;
          const payload = message.cOptional;
          if (payload === 0n) {
            payloadAtlas = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadAtlas = varintSizeFromValue(payload);
          } else {
            payloadAtlas = 8;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(58n, payloadSize, true) + payloadSize + fallbackAtlas.$size, cOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('dOptional' in message) {
          let payloadAtlas;
          const payload = message.dOptional;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadAtlas = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadAtlas = varintSizeFromValue(zigzag);
            } else {
              payloadAtlas = 8;
            }
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(59n, payloadSize, true) + payloadSize + fallbackAtlas.$size, dOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('eOptional' in message) {
          let payloadAtlas;
          const payload = message.eOptional;
          if (payload) {
            payloadAtlas = 1;
          } else {
            payloadAtlas = 0;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(60n, payloadSize, true) + payloadSize + fallbackAtlas.$size, eOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('fOptional' in message) {
          let payloadAtlas;
          const payload = message.fOptional;
          payloadAtlas = payload.byteLength;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(61n, payloadSize, false) + payloadSize + fallbackAtlas.$size, fOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('gOptional' in message) {
          let payloadAtlas;
          const payload = message.gOptional;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(62n, payloadSize, false) + payloadSize + fallbackAtlas.$size, gOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('hOptional' in message) {
          let payloadAtlas;
          const payload = message.hOptional;
          payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(63n, payloadSize, false) + payloadSize + fallbackAtlas.$size, hOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('iOptional' in message) {
          let payloadAtlas;
          const payload = message.iOptional;
          payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(64n, payloadSize, false) + payloadSize + fallbackAtlas.$size, iOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('jOptional' in message) {
          let payloadAtlas;
          const payload = message.jOptional;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadAtlas = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadAtlas = varintSizeFromValue(payload);
              } else {
                payloadAtlas = 8;
              }
            }
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(65n, payloadSize, false) + payloadSize + fallbackAtlas.$size, jOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('kOptional' in message) {
          let payloadAtlas;
          const payload = message.kOptional;
          payloadAtlas = 8 * payload.length;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(66n, payloadSize, false) + payloadSize + fallbackAtlas.$size, kOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('lOptional' in message) {
          let payloadAtlas;
          const payload = message.lOptional;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(payload);
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(67n, payloadSize, false) + payloadSize + fallbackAtlas.$size, lOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('mOptional' in message) {
          let payloadAtlas;
          const payload = message.mOptional;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(68n, payloadSize, false) + payloadSize + fallbackAtlas.$size, mOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('nOptional' in message) {
          let payloadAtlas;
          const payload = message.nOptional;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas = 0;
              payloadAtlas = 1;
              arraySize += payloadAtlas;
            }
            payloadAtlas = arraySize;
          }
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(69n, payloadSize, false) + payloadSize + fallbackAtlas.$size, nOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('oOptional' in message) {
          let payloadAtlas;
          const payload = message.oOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = payload.byteLength;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(70n, payloadSize, false) + payloadSize + fallbackAtlas.$size, oOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('pOptional' in message) {
          let payloadAtlas;
          const payload = message.pOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = textEncoder.encode(payload);
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.byteLength;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(71n, payloadSize, false) + payloadSize + fallbackAtlas.$size, pOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('qOptional' in message) {
          let payloadAtlas;
          const payload = message.qOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(72n, payloadSize, false) + payloadSize + fallbackAtlas.$size, qOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('rOptional' in message) {
          let payloadAtlas;
          const payload = message.rOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
              elements.push(payloadAtlas);
              const payloadSize = (payloadAtlas as { $size: number }).$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(73n, payloadSize, false) + payloadSize + fallbackAtlas.$size, rOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('sOptional' in message) {
          let payloadAtlas;
          const payload = message.sOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadAtlas = varintSizeFromValue(payload);
                }
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(74n, payloadSize, false) + payloadSize + fallbackAtlas.$size, sOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('tOptional' in message) {
          let payloadAtlas;
          const payload = message.tOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              payloadAtlas = 8 * payload.length;
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(75n, payloadSize, false) + payloadSize + fallbackAtlas.$size, tOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('uOptional' in message) {
          let payloadAtlas;
          const payload = message.uOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(payload);
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(76n, payloadSize, false) + payloadSize + fallbackAtlas.$size, uOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('vOptional' in message) {
          let payloadAtlas;
          const payload = message.vOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(77n, payloadSize, false) + payloadSize + fallbackAtlas.$size, vOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('wOptional' in message) {
          let payloadAtlas;
          const payload = message.wOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas = 0;
                  payloadAtlas = 1;
                  arraySize += payloadAtlas;
                }
                payloadAtlas = arraySize;
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(78n, payloadSize, false) + payloadSize + fallbackAtlas.$size, wOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('xOptional' in message) {
          let payloadAtlas;
          const payload = message.xOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = payload.byteLength;
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(79n, payloadSize, false) + payloadSize + fallbackAtlas.$size, xOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('yOptional' in message) {
          let payloadAtlas;
          const payload = message.yOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = textEncoder.encode(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = payloadAtlas.byteLength;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(80n, payloadSize, false) + payloadSize + fallbackAtlas.$size, yOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('zOptional' in message) {
          let payloadAtlas;
          const payload = message.zOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Comprehensive.Types.LocalStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(81n, payloadSize, false) + payloadSize + fallbackAtlas.$size, zOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('aaOptional' in message) {
          let payloadAtlas;
          const payload = message.aaOptional;
          {
            let size = 0;
            let elements = [];
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              let payloadAtlas;
              {
                let size = 0;
                let elements = [];
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  let payloadAtlas;
                  payloadAtlas = Degenerate.Types.EmptyStruct.atlas(payload);
                  elements.push(payloadAtlas);
                  const payloadSize = (payloadAtlas as { $size: number }).$size;
                  size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadAtlas = { $size: size, $elements: elements };
              }
              elements.push(payloadAtlas);
              const payloadSize = payloadAtlas.$size;
              size += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadAtlas = { $size: size, $elements: elements };
          }
          const payloadSize = payloadAtlas.$size;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(82n, payloadSize, false) + payloadSize + fallbackAtlas.$size, aaOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        return unreachable(message);
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: BarOut,
        atlas: BarAtlas,
      ): number {
        if ('aRequired' in message) {
          const payload = message.aRequired;
          const payloadAtlas = (atlas as any).aRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          return offset;
        }
        if ('bRequired' in message) {
          const payload = message.bRequired;
          const payloadAtlas = (atlas as any).bRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          if (payloadAtlas !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
          return offset;
        }
        if ('cRequired' in message) {
          const payload = message.cRequired;
          const payloadAtlas = (atlas as any).cRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          return offset;
        }
        if ('dRequired' in message) {
          const payload = message.dRequired;
          const payloadAtlas = (atlas as any).dRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          return offset;
        }
        if ('eRequired' in message) {
          const payload = message.eRequired;
          const payloadAtlas = (atlas as any).eRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          return offset;
        }
        if ('fRequired' in message) {
          const payload = message.fRequired;
          const payloadAtlas = (atlas as any).fRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
          return offset;
        }
        if ('gRequired' in message) {
          const payload = message.gRequired;
          const payloadAtlas = (atlas as any).gRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        if ('hRequired' in message) {
          const payload = message.hRequired;
          const payloadAtlas = (atlas as any).hRequired as Comprehensive.Types.LocalStructAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          return offset;
        }
        if ('iRequired' in message) {
          const payload = message.iRequired;
          const payloadAtlas = (atlas as any).iRequired as Degenerate.Types.EmptyStructAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          return offset;
        }
        if ('jRequired' in message) {
          const payload = message.jRequired;
          const payloadAtlas = (atlas as any).jRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          return offset;
        }
        if ('kRequired' in message) {
          const payload = message.kRequired;
          const payloadAtlas = (atlas as any).kRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
          return offset;
        }
        if ('lRequired' in message) {
          const payload = message.lRequired;
          const payloadAtlas = (atlas as any).lRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          return offset;
        }
        if ('mRequired' in message) {
          const payload = message.mRequired;
          const payloadAtlas = (atlas as any).mRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          return offset;
        }
        if ('nRequired' in message) {
          const payload = message.nRequired;
          const payloadAtlas = (atlas as any).nRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          return offset;
        }
        if ('oRequired' in message) {
          const payload = message.oRequired;
          const payloadAtlas = (atlas as any).oRequired as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
          return offset;
        }
        if ('pRequired' in message) {
          const payload = message.pRequired;
          const payloadAtlas = (atlas as any).pRequired as { $size: number; $elements: Uint8Array[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
              {
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(payloadAtlas, offset);
                offset += payloadAtlas.byteLength;
              }
            }
          }
          return offset;
        }
        if ('qRequired' in message) {
          const payload = message.qRequired;
          const payloadAtlas = (atlas as any).qRequired as { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
          return offset;
        }
        if ('rRequired' in message) {
          const payload = message.rRequired;
          const payloadAtlas = (atlas as any).rRequired as { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
          return offset;
        }
        if ('sRequired' in message) {
          const payload = message.sRequired;
          const payloadAtlas = (atlas as any).sRequired as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          return offset;
        }
        if ('tRequired' in message) {
          const payload = message.tRequired;
          const payloadAtlas = (atlas as any).tRequired as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
          return offset;
        }
        if ('uRequired' in message) {
          const payload = message.uRequired;
          const payloadAtlas = (atlas as any).uRequired as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          return offset;
        }
        if ('vRequired' in message) {
          const payload = message.vRequired;
          const payloadAtlas = (atlas as any).vRequired as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          return offset;
        }
        if ('wRequired' in message) {
          const payload = message.wRequired;
          const payloadAtlas = (atlas as any).wRequired as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          return offset;
        }
        if ('xRequired' in message) {
          const payload = message.xRequired;
          const payloadAtlas = (atlas as any).xRequired as { $size: number; $elements: { $size: number; $elements: number[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
          return offset;
        }
        if ('yRequired' in message) {
          const payload = message.yRequired;
          const payloadAtlas = (atlas as any).yRequired as { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                  {
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(payloadAtlas, offset);
                    offset += payloadAtlas.byteLength;
                  }
                }
              }
            }
          }
          return offset;
        }
        if ('zRequired' in message) {
          const payload = message.zRequired;
          const payloadAtlas = (atlas as any).zRequired as { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
          return offset;
        }
        if ('aaRequired' in message) {
          const payload = message.aaRequired;
          const payloadAtlas = (atlas as any).aaRequired as { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
          return offset;
        }
        if ('aAsymmetric' in message) {
          const payload = message.aAsymmetric;
          const payloadAtlas = (atlas as any).aAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('bAsymmetric' in message) {
          const payload = message.bAsymmetric;
          const payloadAtlas = (atlas as any).bAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
          if (payloadAtlas !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('cAsymmetric' in message) {
          const payload = message.cAsymmetric;
          const payloadAtlas = (atlas as any).cAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('dAsymmetric' in message) {
          const payload = message.dAsymmetric;
          const payloadAtlas = (atlas as any).dAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 31n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('eAsymmetric' in message) {
          const payload = message.eAsymmetric;
          const payloadAtlas = (atlas as any).eAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('fAsymmetric' in message) {
          const payload = message.fAsymmetric;
          const payloadAtlas = (atlas as any).fAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('gAsymmetric' in message) {
          const payload = message.gAsymmetric;
          const payloadAtlas = (atlas as any).gAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('hAsymmetric' in message) {
          const payload = message.hAsymmetric;
          const payloadAtlas = (atlas as any).hAsymmetric as Comprehensive.Types.LocalStructAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('iAsymmetric' in message) {
          const payload = message.iAsymmetric;
          const payloadAtlas = (atlas as any).iAsymmetric as Degenerate.Types.EmptyStructAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('jAsymmetric' in message) {
          const payload = message.jAsymmetric;
          const payloadAtlas = (atlas as any).jAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('kAsymmetric' in message) {
          const payload = message.kAsymmetric;
          const payloadAtlas = (atlas as any).kAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('lAsymmetric' in message) {
          const payload = message.lAsymmetric;
          const payloadAtlas = (atlas as any).lAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('mAsymmetric' in message) {
          const payload = message.mAsymmetric;
          const payloadAtlas = (atlas as any).mAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('nAsymmetric' in message) {
          const payload = message.nAsymmetric;
          const payloadAtlas = (atlas as any).nAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('oAsymmetric' in message) {
          const payload = message.oAsymmetric;
          const payloadAtlas = (atlas as any).oAsymmetric as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('pAsymmetric' in message) {
          const payload = message.pAsymmetric;
          const payloadAtlas = (atlas as any).pAsymmetric as { $size: number; $elements: Uint8Array[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
              {
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(payloadAtlas, offset);
                offset += payloadAtlas.byteLength;
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('qAsymmetric' in message) {
          const payload = message.qAsymmetric;
          const payloadAtlas = (atlas as any).qAsymmetric as { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('rAsymmetric' in message) {
          const payload = message.rAsymmetric;
          const payloadAtlas = (atlas as any).rAsymmetric as { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('sAsymmetric' in message) {
          const payload = message.sAsymmetric;
          const payloadAtlas = (atlas as any).sAsymmetric as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('tAsymmetric' in message) {
          const payload = message.tAsymmetric;
          const payloadAtlas = (atlas as any).tAsymmetric as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 47n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('uAsymmetric' in message) {
          const payload = message.uAsymmetric;
          const payloadAtlas = (atlas as any).uAsymmetric as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 48n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('vAsymmetric' in message) {
          const payload = message.vAsymmetric;
          const payloadAtlas = (atlas as any).vAsymmetric as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 49n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('wAsymmetric' in message) {
          const payload = message.wAsymmetric;
          const payloadAtlas = (atlas as any).wAsymmetric as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 50n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('xAsymmetric' in message) {
          const payload = message.xAsymmetric;
          const payloadAtlas = (atlas as any).xAsymmetric as { $size: number; $elements: { $size: number; $elements: number[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 51n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('yAsymmetric' in message) {
          const payload = message.yAsymmetric;
          const payloadAtlas = (atlas as any).yAsymmetric as { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 52n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                  {
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(payloadAtlas, offset);
                    offset += payloadAtlas.byteLength;
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('zAsymmetric' in message) {
          const payload = message.zAsymmetric;
          const payloadAtlas = (atlas as any).zAsymmetric as { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 53n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('aaAsymmetric' in message) {
          const payload = message.aaAsymmetric;
          const payloadAtlas = (atlas as any).aaAsymmetric as { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 54n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('aOptional' in message) {
          const payload = message.aOptional;
          const payloadAtlas = (atlas as any).aOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 56n, payloadSize, false);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('bOptional' in message) {
          const payload = message.bOptional;
          const payloadAtlas = (atlas as any).bOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 57n, payloadSize, false);
          if (payloadAtlas !== 0) {
            dataView.setFloat64(offset, payload, true);
            offset += 8;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('cOptional' in message) {
          const payload = message.cOptional;
          const payloadAtlas = (atlas as any).cOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 58n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('dOptional' in message) {
          const payload = message.dOptional;
          const payloadAtlas = (atlas as any).dOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 59n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('eOptional' in message) {
          const payload = message.eOptional;
          const payloadAtlas = (atlas as any).eOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 60n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('fOptional' in message) {
          const payload = message.fOptional;
          const payloadAtlas = (atlas as any).fOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 61n, payloadSize, false);
          {
            const sourceBuffer = new Uint8Array(payload);
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(sourceBuffer, offset);
            offset += sourceBuffer.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('gOptional' in message) {
          const payload = message.gOptional;
          const payloadAtlas = (atlas as any).gOptional as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 62n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('hOptional' in message) {
          const payload = message.hOptional;
          const payloadAtlas = (atlas as any).hOptional as Comprehensive.Types.LocalStructAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 63n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('iOptional' in message) {
          const payload = message.iOptional;
          const payloadAtlas = (atlas as any).iOptional as Degenerate.Types.EmptyStructAtlas;
          const payloadSize = (payloadAtlas as { $size: number }).$size;
          offset = serializeFieldHeader(dataView, offset, 64n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('jOptional' in message) {
          const payload = message.jOptional;
          const payloadAtlas = (atlas as any).jOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 65n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('kOptional' in message) {
          const payload = message.kOptional;
          const payloadAtlas = (atlas as any).kOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 66n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              dataView.setFloat64(offset, payload, true);
              offset += 8;
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('lOptional' in message) {
          const payload = message.lOptional;
          const payloadAtlas = (atlas as any).lOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 67n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('mOptional' in message) {
          const payload = message.mOptional;
          const payloadAtlas = (atlas as any).mOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 68n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('nOptional' in message) {
          const payload = message.nOptional;
          const payloadAtlas = (atlas as any).nOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 69n, payloadSize, false);
          {
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('oOptional' in message) {
          const payload = message.oOptional;
          const payloadAtlas = (atlas as any).oOptional as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 70n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const sourceBuffer = new Uint8Array(payload);
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(sourceBuffer, offset);
                offset += sourceBuffer.byteLength;
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('pOptional' in message) {
          const payload = message.pOptional;
          const payloadAtlas = (atlas as any).pOptional as { $size: number; $elements: Uint8Array[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 71n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
              {
                const targetBuffer = new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset,
                  dataView.byteLength,
                );
                targetBuffer.set(payloadAtlas, offset);
                offset += payloadAtlas.byteLength;
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('qOptional' in message) {
          const payload = message.qOptional;
          const payloadAtlas = (atlas as any).qOptional as { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 72n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('rOptional' in message) {
          const payload = message.rOptional;
          const payloadAtlas = (atlas as any).rOptional as { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 73n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
              offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('sOptional' in message) {
          const payload = message.sOptional;
          const payloadAtlas = (atlas as any).sOptional as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 74n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('tOptional' in message) {
          const payload = message.tOptional;
          const payloadAtlas = (atlas as any).tOptional as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 75n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  dataView.setFloat64(offset, payload, true);
                  offset += 8;
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('uOptional' in message) {
          const payload = message.uOptional;
          const payloadAtlas = (atlas as any).uOptional as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 76n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('vOptional' in message) {
          const payload = message.vOptional;
          const payloadAtlas = (atlas as any).vOptional as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 77n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('wOptional' in message) {
          const payload = message.wOptional;
          const payloadAtlas = (atlas as any).wOptional as { $size: number; $elements: number[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 78n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
              {
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('xOptional' in message) {
          const payload = message.xOptional;
          const payloadAtlas = (atlas as any).xOptional as { $size: number; $elements: { $size: number; $elements: number[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 79n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas));
                  {
                    const sourceBuffer = new Uint8Array(payload);
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(sourceBuffer, offset);
                    offset += sourceBuffer.byteLength;
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('yOptional' in message) {
          const payload = message.yOptional;
          const payloadAtlas = (atlas as any).yOptional as { $size: number; $elements: { $size: number; $elements: Uint8Array[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 80n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.byteLength));
                  {
                    const targetBuffer = new Uint8Array(
                      dataView.buffer,
                      dataView.byteOffset,
                      dataView.byteLength,
                    );
                    targetBuffer.set(payloadAtlas, offset);
                    offset += payloadAtlas.byteLength;
                  }
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('zOptional' in message) {
          const payload = message.zOptional;
          const payloadAtlas = (atlas as any).zOptional as { $size: number; $elements: { $size: number; $elements: Comprehensive.Types.LocalStructAtlas[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 81n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Comprehensive.Types.LocalStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        if ('aaOptional' in message) {
          const payload = message.aaOptional;
          const payloadAtlas = (atlas as any).aaOptional as { $size: number; $elements: { $size: number; $elements: Degenerate.Types.EmptyStructAtlas[] }[] };
          const payloadSize = payloadAtlas.$size;
          offset = serializeFieldHeader(dataView, offset, 82n, payloadSize, false);
          {
            const oldPayload = payload;
            const oldPayloadAtlas = payloadAtlas;
            for (let i = 0; i < oldPayload.length; i += 1) {
              const payload = oldPayload[i];
              const payloadAtlas = oldPayloadAtlas.$elements[i];
              offset = serializeVarint(dataView, offset, BigInt(payloadAtlas.$size));
              {
                const oldPayload = payload;
                const oldPayloadAtlas = payloadAtlas;
                for (let i = 0; i < oldPayload.length; i += 1) {
                  const payload = oldPayload[i];
                  const payloadAtlas = oldPayloadAtlas.$elements[i];
                  offset = serializeVarint(dataView, offset, BigInt((payloadAtlas as { $size: number }).$size));
                  offset = Degenerate.Types.EmptyStruct.serializeWithAtlasUnsafe(dataView, offset, payload, payloadAtlas);
                }
              }
            }
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as BarAtlas);
          return offset;
        }
        return unreachable(message);
      }

      export function deserializeUnsafe(dataView: DataView): BarIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'aRequired',
                aRequired: payload,
              };
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return {
                $field: 'bRequired',
                bRequired: payload,
              };
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return {
                $field: 'cRequired',
                cRequired: payload,
              };
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return {
                $field: 'dRequired',
                dRequired: payload,
              };
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return {
                $field: 'eRequired',
                eRequired: payload,
              };
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              return {
                $field: 'fRequired',
                fRequired: payload,
              };
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'gRequired',
                gRequired: payload,
              };
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'hRequired',
                hRequired: payload,
              };
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'iRequired',
                iRequired: payload,
              };
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              return {
                $field: 'jRequired',
                jRequired: payload,
              };
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'kRequired',
                kRequired: payload,
              };
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'lRequired',
                lRequired: payload,
              };
            }
            case 12n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'mRequired',
                mRequired: payload,
              };
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'nRequired',
                nRequired: payload,
              };
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'oRequired',
                oRequired: payload,
              };
            }
            case 15n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'pRequired',
                pRequired: payload,
              };
            }
            case 16n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'qRequired',
                qRequired: payload,
              };
            }
            case 17n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'rRequired',
                rRequired: payload,
              };
            }
            case 18n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'sRequired',
                sRequired: payload,
              };
            }
            case 19n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'tRequired',
                tRequired: payload,
              };
            }
            case 20n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'uRequired',
                uRequired: payload,
              };
            }
            case 21n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'vRequired',
                vRequired: payload,
              };
            }
            case 22n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'wRequired',
                wRequired: payload,
              };
            }
            case 23n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'xRequired',
                xRequired: payload,
              };
            }
            case 24n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'yRequired',
                yRequired: payload,
              };
            }
            case 25n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'zRequired',
                zRequired: payload,
              };
            }
            case 26n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'aaRequired',
                aaRequired: payload,
              };
            }
            case 28n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'aAsymmetric',
                aAsymmetric: payload,
              };
            }
            case 29n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return {
                $field: 'bAsymmetric',
                bAsymmetric: payload,
              };
            }
            case 30n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return {
                $field: 'cAsymmetric',
                cAsymmetric: payload,
              };
            }
            case 31n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return {
                $field: 'dAsymmetric',
                dAsymmetric: payload,
              };
            }
            case 32n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return {
                $field: 'eAsymmetric',
                eAsymmetric: payload,
              };
            }
            case 33n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              return {
                $field: 'fAsymmetric',
                fAsymmetric: payload,
              };
            }
            case 34n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'gAsymmetric',
                gAsymmetric: payload,
              };
            }
            case 35n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'hAsymmetric',
                hAsymmetric: payload,
              };
            }
            case 36n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              return {
                $field: 'iAsymmetric',
                iAsymmetric: payload,
              };
            }
            case 37n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              return {
                $field: 'jAsymmetric',
                jAsymmetric: payload,
              };
            }
            case 38n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'kAsymmetric',
                kAsymmetric: payload,
              };
            }
            case 39n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'lAsymmetric',
                lAsymmetric: payload,
              };
            }
            case 40n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'mAsymmetric',
                mAsymmetric: payload,
              };
            }
            case 41n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              return {
                $field: 'nAsymmetric',
                nAsymmetric: payload,
              };
            }
            case 42n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'oAsymmetric',
                oAsymmetric: payload,
              };
            }
            case 43n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'pAsymmetric',
                pAsymmetric: payload,
              };
            }
            case 44n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'qAsymmetric',
                qAsymmetric: payload,
              };
            }
            case 45n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'rAsymmetric',
                rAsymmetric: payload,
              };
            }
            case 46n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'sAsymmetric',
                sAsymmetric: payload,
              };
            }
            case 47n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'tAsymmetric',
                tAsymmetric: payload,
              };
            }
            case 48n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'uAsymmetric',
                uAsymmetric: payload,
              };
            }
            case 49n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'vAsymmetric',
                vAsymmetric: payload,
              };
            }
            case 50n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'wAsymmetric',
                wAsymmetric: payload,
              };
            }
            case 51n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'xAsymmetric',
                xAsymmetric: payload,
              };
            }
            case 52n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'yAsymmetric',
                yAsymmetric: payload,
              };
            }
            case 53n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'zAsymmetric',
                zAsymmetric: payload,
              };
            }
            case 54n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              return {
                $field: 'aaAsymmetric',
                aaAsymmetric: payload,
              };
            }
            case 56n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'aOptional',
                aOptional: payload,
                $fallback,
              };
            }
            case 57n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'bOptional',
                bOptional: payload,
                $fallback,
              };
            }
            case 58n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'cOptional',
                cOptional: payload,
                $fallback,
              };
            }
            case 59n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'dOptional',
                dOptional: payload,
                $fallback,
              };
            }
            case 60n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'eOptional',
                eOptional: payload,
                $fallback,
              };
            }
            case 61n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + dataView.byteLength,
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'fOptional',
                fOptional: payload,
                $fallback,
              };
            }
            case 62n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'gOptional',
                gOptional: payload,
                $fallback,
              };
            }
            case 63n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'hOptional',
                hOptional: payload,
                $fallback,
              };
            }
            case 64n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'iOptional',
                iOptional: payload,
                $fallback,
              };
            }
            case 65n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(null) as null[];
                }
                payload = newPayload;
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'jOptional',
                jOptional: payload,
                $fallback,
              };
            }
            case 66n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload = dataView.getFloat64(offset, true);
                      offset += 8;
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'kOptional',
                kOptional: payload,
                $fallback,
              };
            }
            case 67n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'lOptional',
                lOptional: payload,
                $fallback,
              };
            }
            case 68n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      [offset, payload] = deserializeVarint(dataView, offset);
                      payload = zigzagDecode(payload);
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'mOptional',
                mOptional: payload,
                $fallback,
              };
            }
            case 69n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[] = [];
              {
                const payloadAlias = payload;
                {
                  while (true) {
                    try {
                      let payload;
                      {
                        let newPayload;
                        {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          newPayload = payload !== 0n;
                        }
                        payload = newPayload;
                      }
                      payloadAlias.push(payload);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'nOptional',
                nOptional: payload,
                $fallback,
              };
            }
            case 70n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + dataView.byteLength,
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'oOptional',
                oOptional: payload,
                $fallback,
              };
            }
            case 71n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = textDecoder.decode(
                      new Uint8Array(
                        dataView.buffer,
                        dataView.byteOffset + offset,
                        dataView.byteLength - offset,
                      ),
                    );
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'pOptional',
                pOptional: payload,
                $fallback,
              };
            }
            case 72n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'qOptional',
                qOptional: payload,
                $fallback,
              };
            }
            case 73n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                    offset = dataView.byteLength;
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'rOptional',
                rOptional: payload,
                $fallback,
              };
            }
            case 74n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: null[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(null) as null[];
                      }
                      payload = newPayload;
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'sOptional',
                sOptional: payload,
                $fallback,
              };
            }
            case 75n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: number[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: number[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload = dataView.getFloat64(offset, true);
                            offset += 8;
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'tOptional',
                tOptional: payload,
                $fallback,
              };
            }
            case 76n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'uOptional',
                uOptional: payload,
                $fallback,
              };
            }
            case 77n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: bigint[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: bigint[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            [offset, payload] = deserializeVarint(dataView, offset);
                            payload = zigzagDecode(payload);
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'vOptional',
                vOptional: payload,
                $fallback,
              };
            }
            case 78n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: boolean[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: boolean[] = [];
                    {
                      const payloadAlias = payload;
                      {
                        while (true) {
                          try {
                            let payload;
                            {
                              let newPayload;
                              {
                                let payload;
                                [offset, payload] = deserializeVarint(dataView, offset);
                                newPayload = payload !== 0n;
                              }
                              payload = newPayload;
                            }
                            payloadAlias.push(payload);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'wOptional',
                wOptional: payload,
                $fallback,
              };
            }
            case 79n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: ArrayBuffer[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: ArrayBuffer[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + dataView.byteLength,
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'xOptional',
                xOptional: payload,
                $fallback,
              };
            }
            case 80n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: string[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: string[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = textDecoder.decode(
                            new Uint8Array(
                              dataView.buffer,
                              dataView.byteOffset + offset,
                              dataView.byteLength - offset,
                            ),
                          );
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'yOptional',
                yOptional: payload,
                $fallback,
              };
            }
            case 81n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Comprehensive.Types.LocalStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'zOptional',
                zOptional: payload,
                $fallback,
              };
            }
            case 82n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                const dataViewAlias = dataView;
                const payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    try {
                      [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                    } catch (e) {
                      if (e instanceof RangeError) {
                        break;
                      } else {
                        throw e;
                      }
                    }
                    const dataView = new DataView(
                      dataViewAlias.buffer,
                      dataViewAlias.byteOffset + offset,
                      Number(payloadSizeBig),
                    );
                    const oldOffset = offset;
                    offset = 0;
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      const dataViewAlias = dataView;
                      const payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          try {
                            [offset, payloadSizeBig] = deserializeVarint(dataViewAlias, offset);
                          } catch (e) {
                            if (e instanceof RangeError) {
                              break;
                            } else {
                              throw e;
                            }
                          }
                          const dataView = new DataView(
                            dataViewAlias.buffer,
                            dataViewAlias.byteOffset + offset,
                            Number(payloadSizeBig),
                          );
                          const oldOffset = offset;
                          offset = 0;
                          let payload = Degenerate.Types.EmptyStruct.deserializeUnsafe(dataView);
                          offset = dataView.byteLength;
                          offset += oldOffset;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    offset += oldOffset;
                    payloadAlias.push(payload);
                  }
                }
              }
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'aaOptional',
                aaOptional: payload,
                $fallback,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }
    }
  }
}

export namespace Degenerate {
  export namespace Types {
    export type EmptyStructAtlas = {
      $size: number;
    };

    export type EmptyStructOut = {
    };

    export type EmptyStructIn = {
    };

    export namespace EmptyStruct {
      export function size(message: EmptyStructOut): number {
        return 0;
      }

      export function serialize(message: EmptyStructOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): EmptyStructIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: EmptyStructOut): EmptyStructAtlas {
        let size = 0;

        return {
          $size: size,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: EmptyStructOut,
        atlas: EmptyStructAtlas,
      ): number {
        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): EmptyStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            default:
              offset += payloadSize;
              break;
          }
        }

        return {
        };
      }
    }

    export type EmptyChoiceAtlas = never;

    export type EmptyChoiceOut = never;

    export type EmptyChoiceIn = never;

    export namespace EmptyChoice {
      export function size(message: EmptyChoiceOut): number {
        return 0;
      }

      export function serialize(message: EmptyChoiceOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): EmptyChoiceIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: EmptyChoiceOut): EmptyChoiceAtlas {
        return unreachable(message);
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: EmptyChoiceOut,
        atlas: EmptyChoiceAtlas,
      ): number {
        return unreachable(message);
      }

      export function deserializeUnsafe(dataView: DataView): EmptyChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;

          switch (index) {
            default:
              offset += payloadSize;
              break;
          }
        }
      }
    }
  }
}

export namespace SchemaEvolution {
  export namespace After {
    export type ExampleStructAtlas = {
      $size: number;
      requiredToRequired: Uint8Array;
      requiredToAsymmetric: Uint8Array;
      requiredToOptional: Uint8Array | undefined;
      asymmetricToRequired: Uint8Array;
      asymmetricToAsymmetric: Uint8Array;
      asymmetricToOptional: Uint8Array | undefined;
      optionalToRequired: Uint8Array;
      optionalToAsymmetric: Uint8Array;
      optionalToOptional: Uint8Array | undefined;
      nonexistentToAsymmetric: number;
      nonexistentToOptional: number | undefined;
    };

    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string | undefined;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional: string | undefined;
      optionalToRequired: string;
      optionalToAsymmetric: string;
      optionalToOptional: string | undefined;
      nonexistentToAsymmetric: null;
      nonexistentToOptional: null | undefined;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric: string | undefined;
      requiredToOptional: string | undefined;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string | undefined;
      asymmetricToOptional: string | undefined;
      optionalToRequired: string;
      optionalToAsymmetric: string | undefined;
      optionalToOptional: string | undefined;
      nonexistentToAsymmetric: null | undefined;
      nonexistentToOptional: null | undefined;
    };

    export namespace ExampleStruct {
      export function size(message: ExampleStructOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: ExampleStructOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): ExampleStructIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: ExampleStructOut): ExampleStructAtlas {
        let size = 0;

        let $requiredToRequired, $requiredToAsymmetric, $requiredToOptional, $asymmetricToRequired, $asymmetricToAsymmetric, $asymmetricToOptional, $optionalToRequired, $optionalToAsymmetric, $optionalToOptional, $nonexistentToAsymmetric, $nonexistentToOptional;

        {
          let payloadAtlas;
          const payload = message.requiredToRequired;
          payloadAtlas = textEncoder.encode(payload);
          $requiredToRequired = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.requiredToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          $requiredToAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.requiredToOptional;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $requiredToOptional = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToRequired;
          payloadAtlas = textEncoder.encode(payload);
          $asymmetricToRequired = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          $asymmetricToAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToOptional;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $asymmetricToOptional = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.optionalToRequired;
          payloadAtlas = textEncoder.encode(payload);
          $optionalToRequired = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.optionalToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          $optionalToAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.optionalToOptional;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $optionalToOptional = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.nonexistentToAsymmetric;
          payloadAtlas = 0;
          $nonexistentToAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas;
          size += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.nonexistentToOptional;
          if (payload !== undefined) {
            payloadAtlas = 0;
            $nonexistentToOptional = payloadAtlas;
            const payloadSize = payloadAtlas;
            size += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
          }
        }

        return {
          $size: size,
          requiredToRequired: $requiredToRequired,
          requiredToAsymmetric: $requiredToAsymmetric,
          requiredToOptional: $requiredToOptional,
          asymmetricToRequired: $asymmetricToRequired,
          asymmetricToAsymmetric: $asymmetricToAsymmetric,
          asymmetricToOptional: $asymmetricToOptional,
          optionalToRequired: $optionalToRequired,
          optionalToAsymmetric: $optionalToAsymmetric,
          optionalToOptional: $optionalToOptional,
          nonexistentToAsymmetric: $nonexistentToAsymmetric,
          nonexistentToOptional: $nonexistentToOptional,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: ExampleStructOut,
        atlas: ExampleStructAtlas,
      ): number {
        {
          const payload = message.requiredToRequired;
          const payloadAtlas = atlas.requiredToRequired;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.requiredToAsymmetric;
          const payloadAtlas = atlas.requiredToAsymmetric;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.requiredToOptional;
          const payloadAtlas = atlas.requiredToOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.asymmetricToRequired;
          const payloadAtlas = atlas.asymmetricToRequired;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.asymmetricToAsymmetric;
          const payloadAtlas = atlas.asymmetricToAsymmetric;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.asymmetricToOptional;
          const payloadAtlas = atlas.asymmetricToOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.optionalToRequired;
          const payloadAtlas = atlas.optionalToRequired;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.optionalToAsymmetric;
          const payloadAtlas = atlas.optionalToAsymmetric;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.optionalToOptional;
          const payloadAtlas = atlas.optionalToOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.nonexistentToAsymmetric;
          const payloadAtlas = atlas.nonexistentToAsymmetric;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
        }

        {
          const payload = message.nonexistentToOptional;
          const payloadAtlas = atlas.nonexistentToOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          }
        }

        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): ExampleStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $requiredToRequired, $requiredToAsymmetric, $requiredToOptional, $asymmetricToRequired, $asymmetricToAsymmetric, $asymmetricToOptional, $optionalToRequired, $optionalToAsymmetric, $optionalToOptional, $nonexistentToAsymmetric, $nonexistentToOptional;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToRequired = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToAsymmetric = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToOptional = payload;
              break;
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToRequired = payload;
              break;
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToAsymmetric = payload;
              break;
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToOptional = payload;
              break;
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToRequired = payload;
              break;
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToAsymmetric = payload;
              break;
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToOptional = payload;
              break;
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $nonexistentToAsymmetric = payload;
              break;
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              $nonexistentToOptional = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($requiredToRequired === undefined
          || $asymmetricToRequired === undefined
          || $optionalToRequired === undefined) {
          throw new Error(missingFieldsErrorMessage);
        }

        return {
          requiredToRequired: $requiredToRequired,
          requiredToAsymmetric: $requiredToAsymmetric,
          requiredToOptional: $requiredToOptional,
          asymmetricToRequired: $asymmetricToRequired,
          asymmetricToAsymmetric: $asymmetricToAsymmetric,
          asymmetricToOptional: $asymmetricToOptional,
          optionalToRequired: $optionalToRequired,
          optionalToAsymmetric: $optionalToAsymmetric,
          optionalToOptional: $optionalToOptional,
          nonexistentToAsymmetric: $nonexistentToAsymmetric,
          nonexistentToOptional: $nonexistentToOptional,
        };
      }
    }

    export type ExampleChoiceAtlas =
      | { $size: number; requiredToRequired: Uint8Array }
      | { $size: number; requiredToAsymmetric: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; asymmetricToRequired: Uint8Array }
      | { $size: number; asymmetricToAsymmetric: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; asymmetricToOptional: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; optionalToRequired: Uint8Array }
      | { $size: number; optionalToAsymmetric: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; optionalToOptional: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; nonexistentToRequired: number }
      | { $size: number; nonexistentToAsymmetric: number; $fallback: ExampleChoiceAtlas }
      | { $size: number; nonexistentToOptional: number; $fallback: ExampleChoiceAtlas };

    export type ExampleChoiceOut =
      | { requiredToRequired: string }
      | { requiredToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { asymmetricToRequired: string }
      | { asymmetricToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { asymmetricToOptional: string; $fallback: ExampleChoiceOut }
      | { optionalToRequired: string }
      | { optionalToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { optionalToOptional: string; $fallback: ExampleChoiceOut }
      | { nonexistentToRequired: null }
      | { nonexistentToAsymmetric: null; $fallback: ExampleChoiceOut }
      | { nonexistentToOptional: null; $fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { $field: 'requiredToRequired'; requiredToRequired: string }
      | { $field: 'requiredToAsymmetric'; requiredToAsymmetric: string }
      | { $field: 'asymmetricToRequired'; asymmetricToRequired: string }
      | { $field: 'asymmetricToAsymmetric'; asymmetricToAsymmetric: string }
      | { $field: 'asymmetricToOptional'; asymmetricToOptional: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToRequired'; optionalToRequired: string }
      | { $field: 'optionalToAsymmetric'; optionalToAsymmetric: string }
      | { $field: 'optionalToOptional'; optionalToOptional: string; $fallback: ExampleChoiceIn }
      | { $field: 'nonexistentToRequired'; nonexistentToRequired: null }
      | { $field: 'nonexistentToAsymmetric'; nonexistentToAsymmetric: null }
      | { $field: 'nonexistentToOptional'; nonexistentToOptional: null; $fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(message: ExampleChoiceOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: ExampleChoiceOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): ExampleChoiceIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: ExampleChoiceOut): ExampleChoiceAtlas {
        if ('requiredToRequired' in message) {
          let payloadAtlas;
          const payload = message.requiredToRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(0n, payloadSize, false) + payloadSize, requiredToRequired: payloadAtlas };
        }
        if ('requiredToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.requiredToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(1n, payloadSize, false) + payloadSize + fallbackAtlas.$size, requiredToAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('asymmetricToRequired' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(4n, payloadSize, false) + payloadSize, asymmetricToRequired: payloadAtlas };
        }
        if ('asymmetricToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(5n, payloadSize, false) + payloadSize + fallbackAtlas.$size, asymmetricToAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('asymmetricToOptional' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToOptional;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(6n, payloadSize, false) + payloadSize + fallbackAtlas.$size, asymmetricToOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('optionalToRequired' in message) {
          let payloadAtlas;
          const payload = message.optionalToRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(8n, payloadSize, false) + payloadSize, optionalToRequired: payloadAtlas };
        }
        if ('optionalToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.optionalToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(9n, payloadSize, false) + payloadSize + fallbackAtlas.$size, optionalToAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('optionalToOptional' in message) {
          let payloadAtlas;
          const payload = message.optionalToOptional;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(10n, payloadSize, false) + payloadSize + fallbackAtlas.$size, optionalToOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('nonexistentToRequired' in message) {
          let payloadAtlas;
          const payload = message.nonexistentToRequired;
          payloadAtlas = 0;
          const payloadSize = payloadAtlas;
          return { $size: fieldHeaderSize(12n, payloadSize, false) + payloadSize, nonexistentToRequired: payloadAtlas };
        }
        if ('nonexistentToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.nonexistentToAsymmetric;
          payloadAtlas = 0;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(13n, payloadSize, false) + payloadSize + fallbackAtlas.$size, nonexistentToAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('nonexistentToOptional' in message) {
          let payloadAtlas;
          const payload = message.nonexistentToOptional;
          payloadAtlas = 0;
          const payloadSize = payloadAtlas;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(14n, payloadSize, false) + payloadSize + fallbackAtlas.$size, nonexistentToOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        return unreachable(message);
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: ExampleChoiceOut,
        atlas: ExampleChoiceAtlas,
      ): number {
        if ('requiredToRequired' in message) {
          const payload = message.requiredToRequired;
          const payloadAtlas = (atlas as any).requiredToRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        if ('requiredToAsymmetric' in message) {
          const payload = message.requiredToAsymmetric;
          const payloadAtlas = (atlas as any).requiredToAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('asymmetricToRequired' in message) {
          const payload = message.asymmetricToRequired;
          const payloadAtlas = (atlas as any).asymmetricToRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        if ('asymmetricToAsymmetric' in message) {
          const payload = message.asymmetricToAsymmetric;
          const payloadAtlas = (atlas as any).asymmetricToAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('asymmetricToOptional' in message) {
          const payload = message.asymmetricToOptional;
          const payloadAtlas = (atlas as any).asymmetricToOptional as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('optionalToRequired' in message) {
          const payload = message.optionalToRequired;
          const payloadAtlas = (atlas as any).optionalToRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        if ('optionalToAsymmetric' in message) {
          const payload = message.optionalToAsymmetric;
          const payloadAtlas = (atlas as any).optionalToAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('optionalToOptional' in message) {
          const payload = message.optionalToOptional;
          const payloadAtlas = (atlas as any).optionalToOptional as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('nonexistentToRequired' in message) {
          const payload = message.nonexistentToRequired;
          const payloadAtlas = (atlas as any).nonexistentToRequired as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          return offset;
        }
        if ('nonexistentToAsymmetric' in message) {
          const payload = message.nonexistentToAsymmetric;
          const payloadAtlas = (atlas as any).nonexistentToAsymmetric as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('nonexistentToOptional' in message) {
          const payload = message.nonexistentToOptional;
          const payloadAtlas = (atlas as any).nonexistentToOptional as number;
          const payloadSize = payloadAtlas;
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        return unreachable(message);
      }

      export function deserializeUnsafe(dataView: DataView): ExampleChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToRequired',
                requiredToRequired: payload,
              };
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToAsymmetric',
                requiredToAsymmetric: payload,
              };
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToRequired',
                asymmetricToRequired: payload,
              };
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToAsymmetric',
                asymmetricToAsymmetric: payload,
              };
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'asymmetricToOptional',
                asymmetricToOptional: payload,
                $fallback,
              };
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'optionalToRequired',
                optionalToRequired: payload,
              };
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'optionalToAsymmetric',
                optionalToAsymmetric: payload,
              };
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToOptional',
                optionalToOptional: payload,
                $fallback,
              };
            }
            case 12n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'nonexistentToRequired',
                nonexistentToRequired: payload,
              };
            }
            case 13n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              return {
                $field: 'nonexistentToAsymmetric',
                nonexistentToAsymmetric: payload,
              };
            }
            case 14n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = null;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'nonexistentToOptional',
                nonexistentToOptional: payload,
                $fallback,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }
    }
  }

  export namespace Before {
    export type ExampleStructAtlas = {
      $size: number;
      requiredToRequired: Uint8Array;
      requiredToAsymmetric: Uint8Array;
      requiredToOptional: Uint8Array;
      requiredToNonexistent: Uint8Array;
      asymmetricToRequired: Uint8Array;
      asymmetricToAsymmetric: Uint8Array;
      asymmetricToOptional: Uint8Array;
      asymmetricToNonexistent: Uint8Array;
      optionalToRequired: Uint8Array | undefined;
      optionalToAsymmetric: Uint8Array | undefined;
      optionalToOptional: Uint8Array | undefined;
      optionalToNonexistent: Uint8Array | undefined;
    };

    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional: string;
      asymmetricToNonexistent: string;
      optionalToRequired: string | undefined;
      optionalToAsymmetric: string | undefined;
      optionalToOptional: string | undefined;
      optionalToNonexistent: string | undefined;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired: string | undefined;
      asymmetricToAsymmetric: string | undefined;
      asymmetricToOptional: string | undefined;
      asymmetricToNonexistent: string | undefined;
      optionalToRequired: string | undefined;
      optionalToAsymmetric: string | undefined;
      optionalToOptional: string | undefined;
      optionalToNonexistent: string | undefined;
    };

    export namespace ExampleStruct {
      export function size(message: ExampleStructOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: ExampleStructOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): ExampleStructIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: ExampleStructOut): ExampleStructAtlas {
        let size = 0;

        let $requiredToRequired, $requiredToAsymmetric, $requiredToOptional, $requiredToNonexistent, $asymmetricToRequired, $asymmetricToAsymmetric, $asymmetricToOptional, $asymmetricToNonexistent, $optionalToRequired, $optionalToAsymmetric, $optionalToOptional, $optionalToNonexistent;

        {
          let payloadAtlas;
          const payload = message.requiredToRequired;
          payloadAtlas = textEncoder.encode(payload);
          $requiredToRequired = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.requiredToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          $requiredToAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.requiredToOptional;
          payloadAtlas = textEncoder.encode(payload);
          $requiredToOptional = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.requiredToNonexistent;
          payloadAtlas = textEncoder.encode(payload);
          $requiredToNonexistent = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(3n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToRequired;
          payloadAtlas = textEncoder.encode(payload);
          $asymmetricToRequired = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          $asymmetricToAsymmetric = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToOptional;
          payloadAtlas = textEncoder.encode(payload);
          $asymmetricToOptional = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.asymmetricToNonexistent;
          payloadAtlas = textEncoder.encode(payload);
          $asymmetricToNonexistent = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          let payloadAtlas;
          const payload = message.optionalToRequired;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $optionalToRequired = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.optionalToAsymmetric;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $optionalToAsymmetric = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.optionalToOptional;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $optionalToOptional = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
        }

        {
          let payloadAtlas;
          const payload = message.optionalToNonexistent;
          if (payload !== undefined) {
            payloadAtlas = textEncoder.encode(payload);
            $optionalToNonexistent = payloadAtlas;
            const payloadSize = payloadAtlas.byteLength;
            size += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
          }
        }

        return {
          $size: size,
          requiredToRequired: $requiredToRequired,
          requiredToAsymmetric: $requiredToAsymmetric,
          requiredToOptional: $requiredToOptional,
          requiredToNonexistent: $requiredToNonexistent,
          asymmetricToRequired: $asymmetricToRequired,
          asymmetricToAsymmetric: $asymmetricToAsymmetric,
          asymmetricToOptional: $asymmetricToOptional,
          asymmetricToNonexistent: $asymmetricToNonexistent,
          optionalToRequired: $optionalToRequired,
          optionalToAsymmetric: $optionalToAsymmetric,
          optionalToOptional: $optionalToOptional,
          optionalToNonexistent: $optionalToNonexistent,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: ExampleStructOut,
        atlas: ExampleStructAtlas,
      ): number {
        {
          const payload = message.requiredToRequired;
          const payloadAtlas = atlas.requiredToRequired;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.requiredToAsymmetric;
          const payloadAtlas = atlas.requiredToAsymmetric;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.requiredToOptional;
          const payloadAtlas = atlas.requiredToOptional;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.requiredToNonexistent;
          const payloadAtlas = atlas.requiredToNonexistent;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.asymmetricToRequired;
          const payloadAtlas = atlas.asymmetricToRequired;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.asymmetricToAsymmetric;
          const payloadAtlas = atlas.asymmetricToAsymmetric;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.asymmetricToOptional;
          const payloadAtlas = atlas.asymmetricToOptional;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.asymmetricToNonexistent;
          const payloadAtlas = atlas.asymmetricToNonexistent;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        {
          const payload = message.optionalToRequired;
          const payloadAtlas = atlas.optionalToRequired;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.optionalToAsymmetric;
          const payloadAtlas = atlas.optionalToAsymmetric;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.optionalToOptional;
          const payloadAtlas = atlas.optionalToOptional;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        {
          const payload = message.optionalToNonexistent;
          const payloadAtlas = atlas.optionalToNonexistent;
          if (payload !== undefined && payloadAtlas !== undefined) {
            const payloadSize = payloadAtlas.byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const targetBuffer = new Uint8Array(
                dataView.buffer,
                dataView.byteOffset,
                dataView.byteLength,
              );
              targetBuffer.set(payloadAtlas, offset);
              offset += payloadAtlas.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): ExampleStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $requiredToRequired, $requiredToAsymmetric, $requiredToOptional, $requiredToNonexistent, $asymmetricToRequired, $asymmetricToAsymmetric, $asymmetricToOptional, $asymmetricToNonexistent, $optionalToRequired, $optionalToAsymmetric, $optionalToOptional, $optionalToNonexistent;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToRequired = payload;
              break;
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToAsymmetric = payload;
              break;
            }
            case 2n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToOptional = payload;
              break;
            }
            case 3n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $requiredToNonexistent = payload;
              break;
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToRequired = payload;
              break;
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToAsymmetric = payload;
              break;
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToOptional = payload;
              break;
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $asymmetricToNonexistent = payload;
              break;
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToRequired = payload;
              break;
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToAsymmetric = payload;
              break;
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToOptional = payload;
              break;
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $optionalToNonexistent = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($requiredToRequired === undefined
          || $requiredToAsymmetric === undefined
          || $requiredToOptional === undefined
          || $requiredToNonexistent === undefined) {
          throw new Error(missingFieldsErrorMessage);
        }

        return {
          requiredToRequired: $requiredToRequired,
          requiredToAsymmetric: $requiredToAsymmetric,
          requiredToOptional: $requiredToOptional,
          requiredToNonexistent: $requiredToNonexistent,
          asymmetricToRequired: $asymmetricToRequired,
          asymmetricToAsymmetric: $asymmetricToAsymmetric,
          asymmetricToOptional: $asymmetricToOptional,
          asymmetricToNonexistent: $asymmetricToNonexistent,
          optionalToRequired: $optionalToRequired,
          optionalToAsymmetric: $optionalToAsymmetric,
          optionalToOptional: $optionalToOptional,
          optionalToNonexistent: $optionalToNonexistent,
        };
      }
    }

    export type ExampleChoiceAtlas =
      | { $size: number; requiredToRequired: Uint8Array }
      | { $size: number; requiredToAsymmetric: Uint8Array }
      | { $size: number; asymmetricToRequired: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; asymmetricToAsymmetric: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; asymmetricToOptional: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; asymmetricToNonexistent: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; optionalToRequired: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; optionalToAsymmetric: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; optionalToOptional: Uint8Array; $fallback: ExampleChoiceAtlas }
      | { $size: number; optionalToNonexistent: Uint8Array; $fallback: ExampleChoiceAtlas };

    export type ExampleChoiceOut =
      | { requiredToRequired: string }
      | { requiredToAsymmetric: string }
      | { asymmetricToRequired: string; $fallback: ExampleChoiceOut }
      | { asymmetricToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { asymmetricToOptional: string; $fallback: ExampleChoiceOut }
      | { asymmetricToNonexistent: string; $fallback: ExampleChoiceOut }
      | { optionalToRequired: string; $fallback: ExampleChoiceOut }
      | { optionalToAsymmetric: string; $fallback: ExampleChoiceOut }
      | { optionalToOptional: string; $fallback: ExampleChoiceOut }
      | { optionalToNonexistent: string; $fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { $field: 'requiredToRequired'; requiredToRequired: string }
      | { $field: 'requiredToAsymmetric'; requiredToAsymmetric: string }
      | { $field: 'asymmetricToRequired'; asymmetricToRequired: string }
      | { $field: 'asymmetricToAsymmetric'; asymmetricToAsymmetric: string }
      | { $field: 'asymmetricToOptional'; asymmetricToOptional: string }
      | { $field: 'asymmetricToNonexistent'; asymmetricToNonexistent: string }
      | { $field: 'optionalToRequired'; optionalToRequired: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToAsymmetric'; optionalToAsymmetric: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToOptional'; optionalToOptional: string; $fallback: ExampleChoiceIn }
      | { $field: 'optionalToNonexistent'; optionalToNonexistent: string; $fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(message: ExampleChoiceOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: ExampleChoiceOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): ExampleChoiceIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: ExampleChoiceOut): ExampleChoiceAtlas {
        if ('requiredToRequired' in message) {
          let payloadAtlas;
          const payload = message.requiredToRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(0n, payloadSize, false) + payloadSize, requiredToRequired: payloadAtlas };
        }
        if ('requiredToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.requiredToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(1n, payloadSize, false) + payloadSize, requiredToAsymmetric: payloadAtlas };
        }
        if ('asymmetricToRequired' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(4n, payloadSize, false) + payloadSize + fallbackAtlas.$size, asymmetricToRequired: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('asymmetricToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(5n, payloadSize, false) + payloadSize + fallbackAtlas.$size, asymmetricToAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('asymmetricToOptional' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToOptional;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(6n, payloadSize, false) + payloadSize + fallbackAtlas.$size, asymmetricToOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('asymmetricToNonexistent' in message) {
          let payloadAtlas;
          const payload = message.asymmetricToNonexistent;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(7n, payloadSize, false) + payloadSize + fallbackAtlas.$size, asymmetricToNonexistent: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('optionalToRequired' in message) {
          let payloadAtlas;
          const payload = message.optionalToRequired;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(8n, payloadSize, false) + payloadSize + fallbackAtlas.$size, optionalToRequired: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('optionalToAsymmetric' in message) {
          let payloadAtlas;
          const payload = message.optionalToAsymmetric;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(9n, payloadSize, false) + payloadSize + fallbackAtlas.$size, optionalToAsymmetric: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('optionalToOptional' in message) {
          let payloadAtlas;
          const payload = message.optionalToOptional;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(10n, payloadSize, false) + payloadSize + fallbackAtlas.$size, optionalToOptional: payloadAtlas, $fallback: fallbackAtlas };
        }
        if ('optionalToNonexistent' in message) {
          let payloadAtlas;
          const payload = message.optionalToNonexistent;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          const fallbackAtlas = atlas(message.$fallback);
          return { $size: fieldHeaderSize(11n, payloadSize, false) + payloadSize + fallbackAtlas.$size, optionalToNonexistent: payloadAtlas, $fallback: fallbackAtlas };
        }
        return unreachable(message);
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: ExampleChoiceOut,
        atlas: ExampleChoiceAtlas,
      ): number {
        if ('requiredToRequired' in message) {
          const payload = message.requiredToRequired;
          const payloadAtlas = (atlas as any).requiredToRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        if ('requiredToAsymmetric' in message) {
          const payload = message.requiredToAsymmetric;
          const payloadAtlas = (atlas as any).requiredToAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        if ('asymmetricToRequired' in message) {
          const payload = message.asymmetricToRequired;
          const payloadAtlas = (atlas as any).asymmetricToRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('asymmetricToAsymmetric' in message) {
          const payload = message.asymmetricToAsymmetric;
          const payloadAtlas = (atlas as any).asymmetricToAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('asymmetricToOptional' in message) {
          const payload = message.asymmetricToOptional;
          const payloadAtlas = (atlas as any).asymmetricToOptional as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('asymmetricToNonexistent' in message) {
          const payload = message.asymmetricToNonexistent;
          const payloadAtlas = (atlas as any).asymmetricToNonexistent as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('optionalToRequired' in message) {
          const payload = message.optionalToRequired;
          const payloadAtlas = (atlas as any).optionalToRequired as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('optionalToAsymmetric' in message) {
          const payload = message.optionalToAsymmetric;
          const payloadAtlas = (atlas as any).optionalToAsymmetric as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('optionalToOptional' in message) {
          const payload = message.optionalToOptional;
          const payloadAtlas = (atlas as any).optionalToOptional as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        if ('optionalToNonexistent' in message) {
          const payload = message.optionalToNonexistent;
          const payloadAtlas = (atlas as any).optionalToNonexistent as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          offset = serializeWithAtlasUnsafe(dataView, offset, message.$fallback, (atlas as any).$fallback as ExampleChoiceAtlas);
          return offset;
        }
        return unreachable(message);
      }

      export function deserializeUnsafe(dataView: DataView): ExampleChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToRequired',
                requiredToRequired: payload,
              };
            }
            case 1n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'requiredToAsymmetric',
                requiredToAsymmetric: payload,
              };
            }
            case 4n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToRequired',
                asymmetricToRequired: payload,
              };
            }
            case 5n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToAsymmetric',
                asymmetricToAsymmetric: payload,
              };
            }
            case 6n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToOptional',
                asymmetricToOptional: payload,
              };
            }
            case 7n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'asymmetricToNonexistent',
                asymmetricToNonexistent: payload,
              };
            }
            case 8n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToRequired',
                optionalToRequired: payload,
                $fallback,
              };
            }
            case 9n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToAsymmetric',
                optionalToAsymmetric: payload,
                $fallback,
              };
            }
            case 10n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToOptional',
                optionalToOptional: payload,
                $fallback,
              };
            }
            case 11n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              const $fallback = deserializeUnsafe(
                new DataView(
                  dataViewAlias.buffer,
                  dataViewAlias.byteOffset + offset,
                  dataViewAlias.byteLength - offset,
                ),
              );
              return {
                $field: 'optionalToNonexistent',
                optionalToNonexistent: payload,
                $fallback,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }
    }
  }

  export namespace Types {
    export type SingletonStructAtlas = {
      $size: number;
      x: Uint8Array;
    };

    export type SingletonStructOut = {
      x: string;
    };

    export type SingletonStructIn = {
      x: string;
    };

    export namespace SingletonStruct {
      export function size(message: SingletonStructOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: SingletonStructOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): SingletonStructIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: SingletonStructOut): SingletonStructAtlas {
        let size = 0;

        let $x;

        {
          let payloadAtlas;
          const payload = message.x;
          payloadAtlas = textEncoder.encode(payload);
          $x = payloadAtlas;
          const payloadSize = payloadAtlas.byteLength;
          size += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        return {
          $size: size,
          x: $x,
        };
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: SingletonStructOut,
        atlas: SingletonStructAtlas,
      ): number {
        {
          const payload = message.x;
          const payloadAtlas = atlas.x;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
        }

        return offset;
      }

      export function deserializeUnsafe(dataView: DataView): SingletonStructIn {
        const dataViewAlias = dataView;

        let offset = 0;

        let $x;

        while (true) {
          let index, payloadSize;

          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              offset += oldOffset;
              $x = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if ($x === undefined) {
          throw new Error(missingFieldsErrorMessage);
        }

        return {
          x: $x,
        };
      }
    }

    export type SingletonChoiceAtlas =
      | { $size: number; x: Uint8Array };

    export type SingletonChoiceOut =
      | { x: string };

    export type SingletonChoiceIn =
      | { $field: 'x'; x: string }
      | { $field: never };

    export namespace SingletonChoice {
      export function size(message: SingletonChoiceOut): number {
        return atlas(message).$size;
      }

      export function serialize(message: SingletonChoiceOut): ArrayBuffer {
        const messageAtlas = atlas(message);
        const arrayBuffer = new ArrayBuffer((messageAtlas as { $size: number }).$size);
        const dataView = new DataView(arrayBuffer);
        serializeWithAtlasUnsafe(dataView, 0, message, messageAtlas);
        return arrayBuffer;
      }

      export function deserialize(dataView: DataView): SingletonChoiceIn | Error {
        try {
          return deserializeUnsafe(dataView);
        } catch (e) {
          return e as Error;
        }
      }

      export function atlas(message: SingletonChoiceOut): SingletonChoiceAtlas {
        if ('x' in message) {
          let payloadAtlas;
          const payload = message.x;
          payloadAtlas = textEncoder.encode(payload);
          const payloadSize = payloadAtlas.byteLength;
          return { $size: fieldHeaderSize(0n, payloadSize, false) + payloadSize, x: payloadAtlas };
        }
        return unreachable(message);
      }

      export function serializeWithAtlasUnsafe(
        dataView: DataView,
        offset: number,
        message: SingletonChoiceOut,
        atlas: SingletonChoiceAtlas,
      ): number {
        if ('x' in message) {
          const payload = message.x;
          const payloadAtlas = (atlas as any).x as Uint8Array;
          const payloadSize = payloadAtlas.byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const targetBuffer = new Uint8Array(
              dataView.buffer,
              dataView.byteOffset,
              dataView.byteLength,
            );
            targetBuffer.set(payloadAtlas, offset);
            offset += payloadAtlas.byteLength;
          }
          return offset;
        }
        return unreachable(message);
      }

      export function deserializeUnsafe(dataView: DataView): SingletonChoiceIn {
        const dataViewAlias = dataView;

        let offset = 0;

        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataViewAlias, offset);
          offset = newOffset;

          switch (index) {
            case 0n: {
              const dataView = new DataView(
                dataViewAlias.buffer,
                dataViewAlias.byteOffset + offset,
                payloadSize,
              );
              const oldOffset = offset;
              offset = 0;
              let payload = textDecoder.decode(
                new Uint8Array(
                  dataView.buffer,
                  dataView.byteOffset + offset,
                  dataView.byteLength - offset,
                ),
              );
              offset = dataView.byteLength;
              return {
                $field: 'x',
                x: payload,
              };
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }
    }
  }
}

export namespace Types {
}
